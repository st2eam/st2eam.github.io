<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>images</title>
      <link href="2099/05/20/images/"/>
      <url>2099/05/20/images/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/r2e391.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> images </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Swing + 图片转字符画</title>
      <link href="2021/06/01/%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/"/>
      <url>2021/06/01/%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scuec.computerschool.javaproject3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Image;</span><br><span class="line"><span class="keyword">import</span> java.awt.Toolkit;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.ImageIcon;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextArea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoveCard</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>{</span><br><span class="line">JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">"LoveCard"</span>);    <span class="comment">//创建一个JFrame对象</span></span><br><span class="line">JPanel jp=<span class="keyword">new</span> JPanel();    <span class="comment">//创建一个JPanel对象</span></span><br><span class="line">JTextArea jt=<span class="keyword">new</span> JTextArea();</span><br><span class="line"><span class="keyword">private</span> JLabel timeLabel;</span><br><span class="line"><span class="keyword">private</span> JLabel timedisplay;</span><br><span class="line"><span class="keyword">private</span> String DEFAULT_TIME_FORMAT = <span class="string">"HH:mm:ss"</span>;<span class="comment">//设置时间格式</span></span><br><span class="line"><span class="keyword">private</span> String time;</span><br><span class="line"><span class="comment">//动态显示时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configTimeArea</span><span class="params">()</span> </span>{</span><br><span class="line">Timer tmr = <span class="keyword">new</span> Timer();</span><br><span class="line">tmr.scheduleAtFixedRate(<span class="keyword">new</span> JLabelTimerTask(),<span class="keyword">new</span> Date(), <span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">JLabelTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>{</span><br><span class="line">SimpleDateFormat dateFormatter = <span class="keyword">new</span> SimpleDateFormat(DEFAULT_TIME_FORMAT);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">time = dateFormatter.format(Calendar.getInstance().getTime());</span><br><span class="line">timedisplay.setText(time);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//图片转字符画</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawPic</span><span class="params">()</span> </span>{</span><br><span class="line">String picPath = <span class="string">"D:\\1583853509270.jpg"</span>;<span class="comment">//建议换一张分辨率小的</span></span><br><span class="line">BufferedImage img;</span><br><span class="line"><span class="comment">//String base = "-'.^,:;+=)?!ITLO8EM#%&amp;@";</span></span><br><span class="line">String base = <span class="string">"@&amp;%#MX8OLTI!?)=+;:,^.'-"</span>;<span class="comment">//从复杂到简单</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">img = ImageIO.read(<span class="keyword">new</span> File(picPath));</span><br><span class="line"><span class="keyword">int</span> width = img.getWidth();</span><br><span class="line"><span class="keyword">int</span> height = img.getHeight();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y += <span class="number">4</span>) {</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x += <span class="number">4</span>) {</span><br><span class="line"><span class="keyword">int</span> pixel = img.getRGB(x, y);</span><br><span class="line"><span class="keyword">int</span> r = (pixel &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, g = (pixel &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, b = pixel &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">double</span> gray = <span class="number">0.299f</span> * r + <span class="number">0.578f</span> * g + <span class="number">0.114f</span> * b;</span><br><span class="line"><span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor(gray * base.length() / <span class="number">256</span>);</span><br><span class="line"><span class="keyword">char</span> symbol = base.charAt(index);</span><br><span class="line">jt.append(symbol+<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//System.out.print(symbol+" ");</span></span><br><span class="line">}</span><br><span class="line">jt.append(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line">}</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//窗口显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFrame</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">//显示Image</span></span><br><span class="line">JLabel jl=<span class="keyword">new</span> JLabel(); <span class="comment">//创建一个标签</span></span><br><span class="line">ImageIcon image = <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\#Study resources\\#Stream\\1583853509270.jpg"</span>);</span><br><span class="line">image.setImage(image.getImage().getScaledInstance(image.getIconHeight()/<span class="number">2</span>, image.getIconWidth()/<span class="number">2</span>,Image.SCALE_SMOOTH ));</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口设置</span></span><br><span class="line">Toolkit toolkit = Toolkit.getDefaultToolkit();<span class="comment">//添加工具包</span></span><br><span class="line">jf.setSize(image.getIconHeight(), image.getIconWidth());</span><br><span class="line"><span class="keyword">int</span> x = (<span class="keyword">int</span>)(toolkit.getScreenSize().getWidth()-jf.getWidth())/<span class="number">2</span>;<span class="comment">//屏幕居中显示</span></span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">int</span>)(toolkit.getScreenSize().getHeight()-jf.getHeight())/<span class="number">2</span>;</span><br><span class="line">jf.setLocation(x, y);</span><br><span class="line">jp.setBackground(Color.white);    <span class="comment">//设置背景色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示时间</span></span><br><span class="line">timeLabel = <span class="keyword">new</span> JLabel(<span class="string">"CurrentTime: "</span>);</span><br><span class="line">timedisplay = <span class="keyword">new</span> JLabel();</span><br><span class="line">configTimeArea();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将组件添加到窗口</span></span><br><span class="line">jt.setSize(image.getIconHeight(), image.getIconWidth());</span><br><span class="line">jt.setFont(<span class="keyword">new</span> Font(<span class="string">"宋体"</span>,<span class="number">20</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">jf.add(jp);</span><br><span class="line">jp.add(timeLabel);<span class="comment">//添加时间标签</span></span><br><span class="line">jp.add(timedisplay);<span class="comment">//添加时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jl.setIcon(image);//添加图片到标签</span></span><br><span class="line"><span class="comment">//jp.add(jl);    //将标签添加到面板</span></span><br><span class="line"></span><br><span class="line">jp.add(jt);<span class="comment">//将字符图片添加到面板</span></span><br><span class="line">drawPic();</span><br><span class="line"></span><br><span class="line">jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式</a></h2><blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a href="https://www.runoob.com/design-pattern/factory-pattern.html">工厂模式</a></h3></blockquote><ul><li><p><strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p></li><li><p><strong>主要解决</strong>：主要解决接口选择的问题。</p></li><li><p><strong>何时使用</strong>：我们明确地计划不同条件下创建不同实例时。</p></li><li><p><strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品。</p></li><li><p><strong>关键代码</strong>：创建过程在其子类执行。</p></li><li><p><strong>应用实例</strong>： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p></li><li><p><strong>优点</strong>： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p></li><li><p><strong>缺点</strong>：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p></li><li><p><strong>使用场景</strong>： </p></li></ul><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li><li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ol><ul><li><strong>注意事项</strong>：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>创建一个接口:</li></ol><ul><li>shape.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape {</span><br><span class="line">   void draw();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="2"><li>创建实现接口的实体类。</li></ol><ul><li>Rectangle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Inside Rectangle::draw() method.");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>Square.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Inside Square::draw() method.");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>Circle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Inside Circle::draw() method.");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li>创建一个工厂，生成基于给定信息的实体类的对象。</li></ol><ul><li>ShapeFactory.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory {</span><br><span class="line">    </span><br><span class="line">   //使用 getShape 方法获取形状类型的对象</span><br><span class="line">   public Shape getShape(String shapeType){</span><br><span class="line">      if(shapeType == null){</span><br><span class="line">         return null;</span><br><span class="line">      }        </span><br><span class="line">      if(shapeType.equalsIgnoreCase("CIRCLE")){</span><br><span class="line">         return new Circle();</span><br><span class="line">      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){</span><br><span class="line">         return new Rectangle();</span><br><span class="line">      } else if(shapeType.equalsIgnoreCase("SQUARE")){</span><br><span class="line">         return new Square();</span><br><span class="line">      }</span><br><span class="line">      return null;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="4"><li>使用该工厂，通过传递类型信息来获取实体类的对象。</li></ol><ul><li>FactoryPatternDemo.java</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPatternDemo {</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) {</span><br><span class="line">      ShapeFactory shapeFactory = new ShapeFactory();</span><br><span class="line"> </span><br><span class="line">      //获取 Circle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape1 = shapeFactory.getShape("CIRCLE");</span><br><span class="line"> </span><br><span class="line">      //调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape2 = shapeFactory.getShape("RECTANGLE");</span><br><span class="line"> </span><br><span class="line">      //调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line"> </span><br><span class="line">      //获取 Square 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape3 = shapeFactory.getShape("SQUARE");</span><br><span class="line"> </span><br><span class="line">      //调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>执行程序，输出结果：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br></pre></td></tr></tbody></table></figure></li></ol><blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3></blockquote><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><ul><li><p><strong>意图</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p></li><li><p><strong>主要解决</strong>：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p></li><li><p><strong>何时使用</strong>：在不想增加很多子类的情况下扩展类。</p></li><li><p><strong>如何解决</strong>：将具体功能职责划分，同时继承装饰者模式。</p></li><li><p><strong>关键代码</strong>： </p></li></ul><ol><li>Component 类充当抽象角色，不应该具体实现。 </li><li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li></ol><ul><li><strong>应用实例</strong>： </li></ul><ol><li>孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 </li><li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li></ol><ul><li><p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li><li><p><strong>缺点</strong>：多层装饰比较复杂。</p></li><li><p><strong>使用场景</strong>： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p></li><li><p><strong>注意事项</strong>：可代替继承。</p></li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol><li>创建一个接口:</li></ol><ul><li>shape.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape {</span><br><span class="line">   void draw();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="2"><li>创建实现接口的实体类。</li></ol><ul><li>Rectangle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Shape: Rectangle");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>Circle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Shape: Circle");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li>创建实现了 Shape 接口的抽象装饰类。</li></ol><ul><li>ShapeFactory.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ShapeDecorator implements Shape {</span><br><span class="line">   protected Shape decoratedShape;</span><br><span class="line"> </span><br><span class="line">   public ShapeDecorator(Shape decoratedShape){</span><br><span class="line">      this.decoratedShape = decoratedShape;</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   public void draw(){</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">   }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="4"><li>创建扩展了 ShapeDecorator 类的实体装饰类。</li></ol><ul><li>RedShapeDecorator.java</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedShapeDecorator extends ShapeDecorator {</span><br><span class="line"> </span><br><span class="line">   public RedShapeDecorator(Shape decoratedShape) {</span><br><span class="line">      super(decoratedShape);     </span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      decoratedShape.draw();         </span><br><span class="line">      setRedBorder(decoratedShape);</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   private void setRedBorder(Shape decoratedShape){</span><br><span class="line">      System.out.println("Border Color: Red");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>使用 RedShapeDecorator 来装饰 Shape 对象。</li></ol><p>DecoratorPatternDemo.java</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DecoratorPatternDemo {</span><br><span class="line">   public static void main(String[] args) {</span><br><span class="line"> </span><br><span class="line">      Shape circle = new Circle();</span><br><span class="line">      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());</span><br><span class="line">      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());</span><br><span class="line">      //Shape redCircle = new RedShapeDecorator(new Circle());</span><br><span class="line">      //Shape redRectangle = new RedShapeDecorator(new Rectangle());</span><br><span class="line">      System.out.println("Circle with normal border");</span><br><span class="line">      circle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println("\nCircle of red border");</span><br><span class="line">      redCircle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println("\nRectangle of red border");</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>执行程序，输出结果：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Circle with normal border</span><br><span class="line">Shape: Circle</span><br><span class="line"></span><br><span class="line">Circle of red border</span><br><span class="line">Shape: Circle</span><br><span class="line">Border Color: Red</span><br><span class="line"></span><br><span class="line">Rectangle of red border</span><br><span class="line">Shape: Rectangle</span><br><span class="line">Border Color: Red</span><br></pre></td></tr></tbody></table></figure><h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h3></li></ol><blockquote><h4 id="情景模拟"><a href="#情景模拟" class="headerlink" title="情景模拟"></a>情景模拟</h4></blockquote><p>我们还是拿汽车来举例子吧。<br>现在的汽车越来越智能化了，什么定速巡航、自动刹车、车道偏离等功能都逐渐进入我们的生活，为我们带来了更为便利的出行。</p><p>假设上述提到的定速巡航、自动刹车、车道偏离三个功能就是我们想要为汽车装饰的功能，汽车默认的功能配置有：基本配置。</p><p>得到具体的汽车（宝马、奥迪、奔驰）后，我们可以选择性地增加装饰功能。</p><blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">class Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">virtual void show() = 0;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 三个实体的汽车类</span><br><span class="line">class Bmw :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "这是一辆宝马汽车，配置有：基本配置";</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">class Audi :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "这是一辆奥迪汽车，配置有：基本配置";</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">class Benz :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "这是一辆奔驰汽车，配置有：基本配置";</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 装饰器1 定速巡航</span><br><span class="line">class Decorator01 :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Decorator01(Car* p) :pCar(p) {}</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">pCar-&gt;show();</span><br><span class="line">cout &lt;&lt; "，定速巡航";</span><br><span class="line">}</span><br><span class="line">private:</span><br><span class="line">Car* pCar;</span><br><span class="line">};</span><br><span class="line">// 装饰器2 自动刹车</span><br><span class="line">class Decorator02 :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Decorator02(Car* p) :pCar(p) {}</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">pCar-&gt;show();</span><br><span class="line">cout &lt;&lt; "，自动刹车";</span><br><span class="line">}</span><br><span class="line">private:</span><br><span class="line">Car* pCar;</span><br><span class="line">};</span><br><span class="line">// 装饰器3 定速巡航</span><br><span class="line">class Decorator03 :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Decorator03(Car* p) :pCar(p) {}</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">pCar-&gt;show();</span><br><span class="line">cout &lt;&lt; "，车道偏离";</span><br><span class="line">}</span><br><span class="line">private:</span><br><span class="line">Car* pCar;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">Car* p1 = new Decorator01(new Bmw());</span><br><span class="line">p1 = new Decorator02(p1);</span><br><span class="line">p1 = new Decorator03(p1);</span><br><span class="line">p1-&gt;show();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Car* p2 = new Decorator02(new Audi());</span><br><span class="line">p2-&gt;show();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Car* p3 = new Decorator03(new Benz());</span><br><span class="line">p3-&gt;show();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4></blockquote><p>可以看到，我们在运行代码中：<br>给宝马汽车增加了Decorator01（定速巡航）、Decorator02（自动刹车）、Decorator03（车道偏离）的配置；<br>给奥迪汽车增加了Decorator02（自动刹车）配置；<br>给奔驰汽车增加了Decorator03（车道偏离）配置。</p><blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a></h3></blockquote><p><code>单例模式（Singleton Pattern）</code><br>是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><ul><li><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></li><li><p><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</p></li><li><p><strong>何时使用</strong>：当您想控制实例数目，节省系统资源的时候。</p></li><li><p><strong>如何解决</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p></li><li><p><strong>关键代码</strong>：构造函数是私有的。</p></li><li><p><strong>应用实例</strong>：</p></li></ul><ol><li>一个班级只有一个班主任。</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ol><ul><li><strong>优点</strong>：</li></ul><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><ul><li><strong>缺点</strong>：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li></ul><blockquote><h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3></blockquote><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉式的特点是延迟加载，比如配置文件，采用懒汉式的方法，顾名思义，懒汉么，很懒的，配置文件的实例直到用到的时候才会加载。</p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式的特点是一开始就加载了，如果说懒汉式是“时间换空间”，那么饿汉式就是“空间换时间”，因为一开始就创建了实例，所以每次用到的之后直接返回就好了。</p><blockquote><h3 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h3></blockquote><ul><li><strong>意图</strong>：定义对象间的一种一对多的以来管辖，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li><li><strong>主要解决</strong>：一个对象状态改变给其他对象通知的问题</li><li><strong>何时使用</strong>：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础</title>
      <link href="2021/05/22/C-%E5%9F%BA%E7%A1%80/"/>
      <url>2021/05/22/C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板是一种类型进行参数化的工具，通常有两种形式</p><ul><li>函数模板<br>  ~函数模板针对仅参数类型不同的函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename type&gt; return-type func-name(parameter list)</span><br><span class="line">{</span><br><span class="line">   // 函数体</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//例：</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; T add(T a, T b)</span><br><span class="line">{</span><br><span class="line">    return a+b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>类模板<br>  ~类模板针对仅数据成员和函数成员类型不同的类<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename type&gt; class 类名</span><br><span class="line">{</span><br><span class="line">    // 类定义</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li>模板的声明或定义只能在全局，命名空间或类范围内进行</li></ul><h4 id="默认类型模板参数"><a href="#默认类型模板参数" class="headerlink" title="默认类型模板参数"></a>默认类型模板参数</h4><p>类模板的类型形参可以有默认值，函数模板的类型形参则不能</p><p>函数模板和类模板都可以为模板的非类型形参提供默认值</p><p>类模板的类型形参的默认值形式为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1,typename T2 = int&gt; class Demo</span><br><span class="line">{</span><br><span class="line">  ...  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="友元模板函数"><a href="#友元模板函数" class="headerlink" title="友元模板函数"></a>友元模板函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?</span><br></pre></td></tr></tbody></table></figure><h4 id="多态的模板实现"><a href="#多态的模板实现" class="headerlink" title="多态的模板实现"></a>多态的模板实现</h4><ul><li>虚函数多态，是动态绑定，运行时多态，使用继承、虚函数，基类指针实现透明的处理不同类型集合的方法</li></ul><ol><li>能够优雅的处理一个包含有不同类型的集合</li><li>可执行代码量通常比较小</li><li>可以对代码进行完全编译；因此不需要发布源码</li></ol><ul><li>模板多态，是静多态</li></ul><h4 id="模板特化和偏特化"><a href="#模板特化和偏特化" class="headerlink" title="模板特化和偏特化"></a>模板特化和偏特化</h4><ul><li><p>模板特化：是指对于模板参数是特定的类型，可以为编译器指定特定的实现</p></li><li><p>模板偏特化：当有多个模板参数时，可以为部分模板参数指定特定的类型来进行特化</p></li><li><p>函数模板只支持全特化</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">class Test</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Test(T1 i, T2 j) :a(i), b(j) { std::cout &lt;&lt; "模板类" &lt;&lt; std::endl; }</span><br><span class="line">private:</span><br><span class="line">T1 a;</span><br><span class="line">T2 b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Test&lt;int, char&gt;</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Test(int i, char j) :a(i), b(j) { std::cout &lt;&lt; "全特化" &lt;&lt; std::endl; }</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template &lt;typename T2&gt;</span><br><span class="line">class Test&lt;char, T2&gt;</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Test(char i, T2 j) :a(i), b(j) { std::cout &lt;&lt; "偏特化" &lt;&lt; std::endl; }</span><br><span class="line">private:</span><br><span class="line">char a;</span><br><span class="line">T2 b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">//////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//模板函数</span><br><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">void fun(T1 a, T2 b)</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; "模板函数" &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">void fun&lt;int, char &gt;(int a, char b)</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; "全特化" &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//函数不存在偏特化：下面的代码是错误的</span><br><span class="line">/*</span><br><span class="line">template&lt;typename T2&gt;</span><br><span class="line">void fun&lt;char,T2&gt;(char a, T2 b)</span><br><span class="line">{</span><br><span class="line">cout&lt;&lt;"偏特化"&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">Test&lt;double, double&gt; t1(0.1, 0.2);</span><br><span class="line">Test&lt;int, char&gt; t2(1, 'A');</span><br><span class="line">Test&lt;char, bool&gt; t3('A', true);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h4></li><li><p>c++模板是一种新的编程范式</p></li><li><p>借助模板参数推理和模板特化</p></li><li><p>将运行期行为用编译期来模拟，最主要的两个点：</p></li></ul><ol><li>用模板特化来模拟运行期的分支判断</li><li>用模板参数递归匹配来模拟运行期的循环流程<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int a_1, int ...a_n&gt;</span><br><span class="line">struct MinValue {</span><br><span class="line">static const int value = a_1 &gt; MinValue&lt;a_n...&gt;::value ? MinValue&lt;a_n...&gt;::value : a_1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;int a, int b&gt;</span><br><span class="line">struct MinValue&lt;a, b&gt; {</span><br><span class="line">static const int value = MinValue&lt;a&gt;::value &lt; MinValue&lt;b&gt;::value ? MinValue&lt;a&gt;::value : MinValue&lt;b&gt;::value;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">//这个版本是需要的</span><br><span class="line">template&lt;int a&gt;</span><br><span class="line">struct MinValue&lt;a&gt; {</span><br><span class="line">static const int value = a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;int a_1, int ...a_n&gt;</span><br><span class="line">struct MaxValue {</span><br><span class="line">static const int value = a_1 &lt; MaxValue&lt;a_n...&gt;::value ? MaxValue&lt;a_n...&gt;::value : a_1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;int a, int b&gt;</span><br><span class="line">struct MaxValue&lt;a, b&gt; {</span><br><span class="line">static const int value = a &gt; b ? a : b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这个版本不需要</span><br><span class="line">// template&lt;int a&gt;</span><br><span class="line">// struct MaxValue&lt;a&gt; {</span><br><span class="line">//  static const int  value = a;</span><br><span class="line">// };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">//编译期查找最大最小值</span><br><span class="line">const int maxResult = MaxValue&lt;8, 5, 2, 10, 6, 1, 9&gt;::value;</span><br><span class="line">const int minResult = MinValue&lt;8, 5, 2, 10, 6, 1, 9&gt;::value;</span><br><span class="line">std::cout &lt;&lt; "MaxValue:" &lt;&lt; maxResult &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; "MinValue:" &lt;&lt; minResult &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2>一般格式如下<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型说明符&gt; operator &lt;运算符符号&gt; (&lt;参数表&gt;)</span><br><span class="line">{</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>除关系运算符”.”     成员指针运算符”.*”  作用域运算符”::” sizeof运算符和三目运算符”?:”以外，c++中所有的运算符都可以重载</li><li>重载运算符限制在c++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符</li><li>运算符重载的实质是函数重载，遵循函数重载的选择原则</li><li>重载之后不能改变运算符的优先级和结合性，也不能够改变运算符操作数的个数及语法结构</li><li>运算符重载不能改变该运算符用于内部类型对象的含义</li><li>运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似</li><li>重载运算符的函数不能有默认的参数，否则就改变了运算符的参数个数</li><li>重载的运算符只能是用户自定义类型</li></ul><h2 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h2><p>语法格式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 类名</span><br><span class="line">{</span><br><span class="line">    返回类型 operator 运算符 (参数表);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="友元运算符重载"><a href="#友元运算符重载" class="headerlink" title="友元运算符重载"></a>友元运算符重载</h2><p>在类的内部，定义友元运算符重载函数的格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class xx</span><br><span class="line">{</span><br><span class="line">    friend &lt;返回类型说明符&gt; operator &lt;运算符符号&gt; (形参表)</span><br><span class="line">    {</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="覆盖-override-与重载-overload"><a href="#覆盖-override-与重载-overload" class="headerlink" title="覆盖(override)与重载(overload)"></a>覆盖(override)与重载(overload)</h2><ul><li><p><strong>成员函数覆盖</strong>是指派生类重新定义基类的虚函数</p></li><li><p><strong>成员函数重载</strong>是指函数名相同，参数不同（数量、类型、次序）</p></li><li><p><strong>成员函数隐藏</strong>（重定义）</p></li></ul><ol><li>不在同一个作用域内（分别位于基类与继承类中）</li><li>函数名字相同</li><li>返回值可以不同</li><li>参数不同。此时，无论有无<code>virtual</code>关键字，基类的函数将被隐藏</li><li>参数相同，但是基类函数没有<code>virtual</code>关键字。此时，基类的函数被隐藏</li></ol><h2 id="2021-04-24"><a href="#2021-04-24" class="headerlink" title="2021/04/24"></a>2021/04/24</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// CMakeProject1.h: 标准系统包含文件的包含文件</span><br><span class="line">// 或项目特定的包含文件。</span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">// TODO: 在此处引用程序需要的其他标头。</span><br><span class="line">class Basic {</span><br><span class="line">public:</span><br><span class="line">Basic(){</span><br><span class="line">int_data = 0;</span><br><span class="line">double_data = 0;</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">virtual ~Basic() {</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"> virtual void Function() {</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"> void Function_2() {</span><br><span class="line"> std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line"> }</span><br><span class="line">private:</span><br><span class="line">int int_data;</span><br><span class="line">double double_data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Superior :virtual public Basic{</span><br><span class="line">public:</span><br><span class="line">Superior() {</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">void Function() override{</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">void Function_2() {</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">Basic* get_basic()</span><br><span class="line">{</span><br><span class="line">return this;</span><br><span class="line">}</span><br><span class="line">~Superior() {</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// CMakeProject1.cpp: 定义应用程序的入口点。</span><br><span class="line"></span><br><span class="line">#include "CMakeProject1.h"</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">Superior* sup = new Superior;</span><br><span class="line">sup-&gt;get_basic()-&gt;Function();</span><br><span class="line">sup-&gt;Function();</span><br><span class="line">sup-&gt;get_basic()-&gt;Function_2();</span><br><span class="line">sup-&gt;Function();</span><br><span class="line">delete sup;</span><br><span class="line">cout &lt;&lt; "--------------------" &lt;&lt; endl;</span><br><span class="line">Basic* base = new Superior;</span><br><span class="line">base-&gt;Function();</span><br><span class="line">delete base;</span><br><span class="line">cout &lt;&lt; "--------------------" &lt;&lt; endl;</span><br><span class="line">Superior sup_2;</span><br><span class="line">Basic* base_2 = &amp;sup_2;</span><br><span class="line">base_2-&gt;Function();</span><br><span class="line">base_2-&gt;Function_2();</span><br><span class="line">return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Basic::Basic</span><br><span class="line">Superior::Superior</span><br><span class="line">Superior::Function</span><br><span class="line">Superior::Function</span><br><span class="line">Basic::Function_2</span><br><span class="line">Superior::Function</span><br><span class="line">Superior::~Superior</span><br><span class="line">Basic::~Basic</span><br><span class="line">--------------------</span><br><span class="line">Basic::Basic</span><br><span class="line">Superior::Superior</span><br><span class="line">Superior::Function</span><br><span class="line">Superior::~Superior</span><br><span class="line">Basic::~Basic</span><br><span class="line">--------------------</span><br><span class="line">Basic::Basic</span><br><span class="line">Superior::Superior</span><br><span class="line">Superior::Function</span><br><span class="line">Basic::Function_2</span><br><span class="line">Superior::~Superior</span><br><span class="line">Basic::~Basic</span><br></pre></td></tr></tbody></table></figure><h2 id="虚函数表-Virtual-Table"><a href="#虚函数表-Virtual-Table" class="headerlink" title="虚函数表 Virtual Table"></a>虚函数表 Virtual Table</h2><h2 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h2><p>如果基类并不需要回收清理什么，那么析构函数就可以是虚构函数</p><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><ul><li><p>一般的建议是作为基类的析构函数是虚函数</p></li><li><p>当指针指向的对象是基类类型时，delete销毁对象的时候并不会调用派生类的析构函数，这样就造成了对象销毁不完整</p><blockquote><p> 总结一下虚析构函数的作用：</p></blockquote></li></ul><blockquote><p>（1）如果基类的析构函数不加virtual关键字<br>当基类的析构函数不声明成虚析构函数的时候，当派生类继承父类，基类的指针指向派生类时，delete掉基类的指针，只调动基类的析构函数，而不调动派生类的析构函数。</p></blockquote><blockquote><p>（2）如果基类的析构函数加virtual关键字<br>当基类的析构函数声明成虚析构函数的时候，当派生类继承基类，基类的指针指向派生类时，delete掉基类的指针，先调动派生类的析构函数，再调动基类的析构函数。</p></blockquote><blockquote><p>原理分析</p></blockquote><p>由于基类的析构函数为虚函数，所以派生类会在所有属性的前面形成虚表，而虚表内部存储的就是基类的虚函数。<br>当delete基类的指针时，由于派生类的析构函数与基类的析构函数构成多态，所以得先调动派生类的析构函数；之所以再调动基类的析构函数，是因为delete的机制所引起的,delete 基类指针所指的空间，要调用基类的析构函数。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><ul><li><p>是指一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class typename :virtual public inheritance{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">Function</span><span class="params">(Argument List)</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2></li><li><p>含有纯虚函数的类就是抽象类</p></li><li><p>抽象类没有完整的信息，只能是派生类的基类</p></li><li><p>抽象类不能有实例，不能有静态成员</p></li><li><p>派生类应该实现抽象类的所有方法</p></li></ul><h2 id="inheritance→get-basic"><a href="#inheritance→get-basic" class="headerlink" title="inheritance→get_basic()"></a>inheritance→get_basic()</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superior</span> :</span><span class="keyword">public</span> basic{</span><br><span class="line"><span class="function">basic* <span class="title">get_basic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">- }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="is-a关系"><a href="#is-a关系" class="headerlink" title="is-a关系"></a>is-a关系</h2><ul><li><p>is-a一般是继承关系</p></li><li><p>has-a一般是组合关系<br><br><br></p></li></ul><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef π   <span class="comment">// 先测试π是否被宏定义过</span></span><br><span class="line">#define π <span class="number">3.1415926</span> <span class="comment">//如果没有则定义并执行程序段1</span></span><br><span class="line"><span class="comment">//程序段1   </span></span><br><span class="line">#<span class="keyword">else</span>       <span class="comment">//如果已经定义则执行程序段2</span></span><br><span class="line"><span class="comment">//程序段2</span></span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure><h2 id="使用编译器通常的流程"><a href="#使用编译器通常的流程" class="headerlink" title="使用编译器通常的流程"></a>使用编译器通常的流程</h2><blockquote><p>.cpp→.obj→.exe</p></blockquote><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote><p>F5 运行<br>F10 单步运行<br>F11 单步运行会进入到函数内</p></blockquote><h2 id="科学计数法表示"><a href="#科学计数法表示" class="headerlink" title="科学计数法表示"></a>科学计数法表示</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; scientific &lt;&lt; π &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><h2 id="保留有效数字"><a href="#保留有效数字" class="headerlink" title="保留有效数字"></a>保留有效数字</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout.precision(3);//保留几位就填几</span><br><span class="line"></span><br><span class="line">//位数不足时</span><br><span class="line">cout.precision(10);</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; 3.1415926;//不足十位</span><br></pre></td></tr></tbody></table></figure><h2 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iomanip&gt;  //不要忘了头文件</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2);//保留几位就填几</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line"></span><br><span class="line">printf("%.2lf", π);//不会影响之后输出</span><br></pre></td></tr></tbody></table></figure><h2 id="A除以B"><a href="#A除以B" class="headerlink" title="A除以B"></a>A除以B</h2><p>给定两个绝对值不超过100的整数A和B，要求你按照“A/B=商”的格式输出结果。</p><blockquote><p>输入格式：<br>输入在第一行给出两个整数A和B（−100≤A,B≤100），数字间以空格分隔。</p></blockquote><blockquote><p>输出格式：<br>在一行中输出结果：如果分母是正数，则输出“A/B=商”；如果分母是负数，则要用括号把分母括起来输出；如果分母为零，则输出的商应为Error。输出的商应保留小数点后2位。</p></blockquote><blockquote><p>输入样例1：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 2</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输出样例1：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1/2=-0.50</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输入样例2：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -3</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输出样例2：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1/(-3)=-0.33</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输入样例3：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 0</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输出样例3：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5/0=Error</span><br></pre></td></tr></tbody></table></figure><blockquote><p>代码如下</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">double a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">//cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2);</span><br><span class="line">if (b == 0)</span><br><span class="line">cout &lt;&lt; a &lt;&lt; "/" &lt;&lt; b &lt;&lt; "=" &lt;&lt; "Error" &lt;&lt; endl;</span><br><span class="line">else if (b &gt; 0)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; a &lt;&lt; "/" &lt;&lt; b &lt;&lt; "=";</span><br><span class="line">printf("%.2lf\n", a/b);</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; a &lt;&lt; "/(" &lt;&lt; b &lt;&lt; ")" &lt;&lt; "=";</span><br><span class="line">printf("%.2lf\n", a/b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数字转string，string转数字de函数"><a href="#数字转string，string转数字de函数" class="headerlink" title="数字转string，string转数字de函数"></a>数字转string，string转数字de函数</h2><p>数字转string 这些都可以</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">to_string(int)</span><br><span class="line"></span><br><span class="line">to_string(long)</span><br><span class="line"></span><br><span class="line">to_string(long long)</span><br><span class="line"></span><br><span class="line">to_string(float)</span><br><span class="line"></span><br><span class="line">to_string(double)</span><br><span class="line"></span><br><span class="line">to_string(long double)</span><br></pre></td></tr></tbody></table></figure><p>string转数字</p><p>头文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line"></span><br><span class="line">stoi(str)//int</span><br><span class="line"></span><br><span class="line">stol(str)//long </span><br><span class="line"></span><br><span class="line">stoll(str)//long long</span><br></pre></td></tr></tbody></table></figure><h2 id="计算栅格路径数"><a href="#计算栅格路径数" class="headerlink" title="计算栅格路径数"></a>计算栅格路径数</h2><p>假设存在一个m*n的栅格，编写函数计算从左下角（坐标：0, 0）走右上角（坐标：m,n）的路径有多少种。只能沿栅格线走，且不能反向走，既只能向上或向右走。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">move</span>(m - <span class="number">1</span>, n) + <span class="built_in">move</span>(m, n - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line">cin &gt;&gt; m &gt;&gt;n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">move</span>(m,n) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;t1, T &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    T temp;</span><br><span class="line">    temp = t1;</span><br><span class="line">    t1 = t2;</span><br><span class="line">    t2 = temp;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T s[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">Swap</span>(s[left], s[(left + right) / <span class="number">2</span>]); <span class="comment">//将中间的这个数和第一个数交换</span></span><br><span class="line">        T i = left, j = right, x = s[left];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x) <span class="comment">// 从右向左找第一个小于x的数</span></span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x) <span class="comment">// 从左向右找第一个大于等于x的数</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">        }</span><br><span class="line">        s[i] = x;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quick_sort</span>(s, left, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></span><br><span class="line">        <span class="built_in">quick_sort</span>(s, i + <span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> aa[<span class="number">10</span>] = {<span class="string">'a'</span>,<span class="string">'v'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'t'</span>,<span class="string">'z'</span>,<span class="string">'q'</span>,<span class="string">'i'</span>,<span class="string">'b'</span>,<span class="string">'x'</span> };</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(aa);<span class="comment">//不同类型记得改</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(aa,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; aa[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="短路现象"><a href="#短路现象" class="headerlink" title="短路现象"></a>短路现象</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=-<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">result = (a++)&amp;(b--);</span><br><span class="line">System.out.println(a+<span class="string">""</span>+b+<span class="string">""</span>+result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c=<span class="number">0</span>,d=<span class="number">1</span>;</span><br><span class="line">result = (a++)|(b--);</span><br><span class="line">System.out.println(c+<span class="string">""</span>+d+<span class="string">""</span>+result);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输出结果</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">001</span><br><span class="line">010</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="2021/05/22/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/05/22/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式有如下优点：</p><ul><li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li><li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li><li>在需要的时间和地点实现功能闭包，使程序更灵活。<h4 id="lambda-表达式的概念和基本用法"><a href="#lambda-表达式的概念和基本用法" class="headerlink" title="lambda 表达式的概念和基本用法"></a>lambda 表达式的概念和基本用法</h4>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。<br>lambda 表达式的语法形式可简单归纳如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ 捕获列表 ] ( 参数表 ) 函数选项 -&gt; 返回值类型 { 函数体 };</span><br><span class="line"></span><br><span class="line">//简单例子 </span><br><span class="line">auto f = [](int a) -&gt; int { return a + 1; };</span><br><span class="line">std::cout &lt;&lt; f(1) &lt;&lt; std::endl;  // 输出: 2</span><br></pre></td></tr></tbody></table></figure>省略 lambda 表达式的返回值定义：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f = [](int a){ return a + 1; };</span><br></pre></td></tr></tbody></table></figure>↑ 这样编译器就会根据 return 语句自动推导出返回值类型。<br>需要注意</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x1 = [](int i){ return i; };  // OK: return type is int</span><br><span class="line">auto x2 = [](){ return { 1, 2 }; };  // error: 无法推导出返回值类型</span><br></pre></td></tr></tbody></table></figure><p>另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f1 = [](){ return 1; };</span><br><span class="line">auto f2 = []{ return 1; };  // 省略空参数表</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-lambda-表达式捕获列表"><a href="#使用-lambda-表达式捕获列表" class="headerlink" title="使用 lambda 表达式捕获列表"></a>使用 lambda 表达式捕获列表</h4><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p><ul><li>[] 不捕获任何变量。</li><li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li>[=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li>[=，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li><li>[this] 捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li></ul><p>lambda表达式的基本用法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class XX</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    int i = 0;</span><br><span class="line">    void func(int x, int y)</span><br><span class="line">    {</span><br><span class="line">        auto x1 = [] { return i; };                    // error，没有捕获外部变量</span><br><span class="line">        auto x2 = [=] { return i + x + y; };           // OK，捕获所有外部变量</span><br><span class="line">        auto x3 = [&amp;] { return i + x + y; };           // OK，捕获所有外部变量</span><br><span class="line">        auto x4 = [this] { return i; };                // OK，捕获this指针</span><br><span class="line">        auto x5 = [this] { return i + x + y; };        // error，没有捕获x、y</span><br><span class="line">        auto x6 = [this, x, y] { return i + x + y; };  // OK，捕获this指针、x、y</span><br><span class="line">        auto x7 = [this] { return i++; };              // OK，捕获this指针，并修改成员的值</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int a = 0, b = 1;</span><br><span class="line">auto f1 = [] { return a; };               // error，没有捕获外部变量</span><br><span class="line">auto f2 = [&amp;] { return a++; };            // OK，捕获所有外部变量，并对a执行自加运算</span><br><span class="line">auto f3 = [=] { return a; };              // OK，捕获所有外部变量，并返回a</span><br><span class="line">auto f4 = [=] { return a++; };            // error，a是以复制方式捕获的，无法修改</span><br><span class="line">auto f5 = [a] { return a + b; };          // error，没有捕获变量b</span><br><span class="line">auto f6 = [a, &amp;b] { return a + (b++); };  // OK，捕获a和b的引用，并对b做自加运算</span><br><span class="line">auto f7 = [=, &amp;b] { return a + (b++); };  // OK，捕获所有外部变量和b的引用，并对b做自加运算</span><br></pre></td></tr></tbody></table></figure><h4 id="lambda-表达式的类型"><a href="#lambda-表达式的类型" class="headerlink" title="lambda 表达式的类型"></a>lambda 表达式的类型</h4><p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure       Type）”。它是一个特殊的，匿名的非 nunion 的类类型。</p><p>因此，我们可以认为它是一个带有 operator() 的类，即仿函数。</p><p>因此，我们可以使用 std::function 和 std::bind 来存储和操作 lambda 表达式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;int(int)&gt;  f1 = [](int a){ return a; };</span><br><span class="line">std::function&lt;int(void)&gt; f2 = std::bind([](int a){ return a; }, 123);</span><br></pre></td></tr></tbody></table></figure><p>另外，对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using func_t = int(*)(int);</span><br><span class="line">func_t f = [](int a){ return a; };</span><br><span class="line">f(123);</span><br></pre></td></tr></tbody></table></figure><p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。</p><p>而一个使用了成员变量的类的operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。</p><p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的operator()默认是const的</p><p>一个const成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。</p><p>需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而捕获变量的 lambda 表达式则不能转换为函数指针。看看下面的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Ptr)(int*);</span><br><span class="line">Ptr p = [](int* p){delete p;};  // 正确，没有状态的lambda（没有捕获）的lambda表达式可以直接转换为函数指针</span><br><span class="line">Ptr p1 = [&amp;](int* p){delete p;};  // 错误，有状态的lambda不能直接转换为函数指针</span><br></pre></td></tr></tbody></table></figure><p>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于windows系统的多线程</title>
      <link href="2021/05/22/%E5%9F%BA%E4%BA%8Ewindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/05/22/%E5%9F%BA%E4%BA%8Ewindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="睡眠排序法"><a href="#睡眠排序法" class="headerlink" title="睡眠排序法"></a>睡眠排序法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Created on Apple Pencil.</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define max(a,b)  a&gt;b? a:b;</span><br><span class="line"></span><br><span class="line">void sleepsort(int i)</span><br><span class="line">{</span><br><span class="line">    Sleep(i*100);</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; ",";</span><br><span class="line">}</span><br><span class="line">int main() {</span><br><span class="line"></span><br><span class="line">    int item[] = { 10,1,3,4,9,4,2,5,3,20};</span><br><span class="line">    int Max = item[0];</span><br><span class="line">    for (int i = 0; i &lt; sizeof(item) &gt;&gt; 2; i++)</span><br><span class="line">    {</span><br><span class="line">        Max = max(Max, item[i]);</span><br><span class="line">    }</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    {</span><br><span class="line">        thread test(sleepsort,item[i]);</span><br><span class="line">        test.detach();</span><br><span class="line">    }</span><br><span class="line">    Sleep(Max*110);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++多线程"></a>C++多线程</h2><ul><li>创建一个线程，不做处理会调用abort函数终止程序</li><li><code>join()</code>函数加入，汇合线程,阻塞主线程,等待子线程执行结束，才会回到主线程中</li><li>一个线程只能join一次</li><li><code>detach()</code>函数 分离，打破依赖关系,把子线程驻留后台</li><li>当线程detach之后，就不能再join了</li><li><code>joinable()</code>判断当前进程是否可以做join或者detach过程，可以则返回true，不可以则返回false<h4 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//线程处理函数</span><br><span class="line">void print_1()</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--子线程1运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">void print_2()</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--子线程2运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">void print_3()</span><br><span class="line">{</span><br><span class="line">Sleep(5000);</span><br><span class="line">cout &lt;&lt; "--子线程3运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class thr</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">void operator ()()</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--子线程thr运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">//创建线程</span><br><span class="line">thread test(print_1);</span><br><span class="line"></span><br><span class="line">test.join();</span><br><span class="line"></span><br><span class="line">thread test_2(print_2);</span><br><span class="line">test_2.join();</span><br><span class="line"></span><br><span class="line">thread test_3(print_3);</span><br><span class="line">test_3.detach();</span><br><span class="line"></span><br><span class="line">thr th;</span><br><span class="line">thread test_4(th);</span><br><span class="line">test_4.join();</span><br><span class="line"></span><br><span class="line">auto lambdathread = []</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--lambda线程运行--" &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">thread test_5(lambdathread);</span><br><span class="line">test_5.join();</span><br><span class="line"></span><br><span class="line">Sleep(1000);</span><br><span class="line">if (test_3.joinable())</span><br><span class="line">{</span><br><span class="line">test_3.detach();</span><br><span class="line">}</span><br><span class="line">else {</span><br><span class="line">cout &lt;&lt; "子线程3已被处理" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--主线程运行--" &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>vector容器装载线程<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void myprint(int i)</span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt;"--thread_num:"&lt;&lt; i &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">int main() </span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; "--主线程执行--" &lt;&lt; endl;</span><br><span class="line">    vector &lt;thread&gt; mythreads;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    {</span><br><span class="line">        mythreads.push_back(thread(myprint, i));</span><br><span class="line">        //mythreads[i].join();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (auto tp = mythreads.begin(); tp != mythreads.end(); ++tp)</span><br><span class="line">    {</span><br><span class="line">        //cout &lt;&lt; tp-&gt;get_id() &lt;&lt; endl;</span><br><span class="line">        tp-&gt;join();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; "--主线程结束--" &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="- 互斥量mutex"></a>- 互斥量mutex</h3><ul><li>互斥量是个类对象，理解成一把锁，多个线程尝试用lock()成员函数来加锁这个锁，只有一个线程能够锁定成功，成功的标志是lock()函数返回</li><li>如果没锁成功，那么流程会卡在lock()这里不断地尝试去锁</li><li>互斥量使用时要注意，保护数据要合适，少了没达到保护效果，多了影响效率</li></ul><h4 id="互斥量的用法"><a href="#互斥量的用法" class="headerlink" title="互斥量的用法"></a>互斥量的用法</h4><ul><li>步骤：先lock(),操作共享数据，再unlock();</li><li>lock()和unlock()要一对一成对使用，每调用一次lock()必然调用一个unlock()</li><li>std::lock_guard类模板：忘记unlock不要紧，guard帮你unlock()</li><li>智能指针(unique_ptr&lt;&gt;)：你忘记释放内存不要紧，ta也帮你释放</li><li>std::lock_guard 可以取代lock()和unlock(),就是使用了lock_guard之后，不能使用lock()和unlock()之中任何一个</li></ul><blockquote><p>原理：</p></blockquote><ul><li>lock_guard构造函数里执行了mutex::lock()</li><li>lock_guard析构函数里执行了mutex::unlock()<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::lock_guard&lt;std::mutex&gt; my_guard(my_mutex);</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// Created on Apple Pencil.</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">list &lt;int&gt; DataQueue;</span><br><span class="line"></span><br><span class="line">class mythread {</span><br><span class="line">public:</span><br><span class="line">    void indata()</span><br><span class="line">    {</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; __FUNCTION__"执行，插入数据" &lt;&lt;i&lt;&lt; endl;</span><br><span class="line">            lock_guard&lt;mutex&gt; myguard(mymutex);</span><br><span class="line">            //mymutex.lock();</span><br><span class="line">            DataQueue.push_back(i);</span><br><span class="line">            //mymutex.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    void outdata()</span><br><span class="line">    {</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">        {</span><br><span class="line">            if (!DataQueue.empty())</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; __FUNCTION__"执行，读出数据" &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                mymutex.lock();</span><br><span class="line">                int command = DataQueue.front();</span><br><span class="line">                DataQueue.pop_front();</span><br><span class="line">                mymutex.unlock();</span><br><span class="line">            }</span><br><span class="line">            else</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; __FUNCTION__"继续执行，但消息队列为空" &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">private:</span><br><span class="line">    mutex mymutex;//创建了一个互斥量</span><br><span class="line">};</span><br><span class="line">int main() </span><br><span class="line">{</span><br><span class="line">    mythread mt;</span><br><span class="line">    thread myindata(&amp;mythread::indata,&amp;mt);</span><br><span class="line">    thread myoutdata(&amp;mythread::outdata, &amp;mt);</span><br><span class="line">    myindata.join();</span><br><span class="line">    myoutdata.join();</span><br><span class="line">    cout &lt;&lt; "--主线程结束--" &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li>死锁前提条件是要有两把锁（两个互斥量）</li><li>现有两个线程A、B，两把锁1、2</li></ul><ol><li>线程A执行的时候，线程先锁1.lock()成功,然后去执行2.lock()[未锁]</li><li>出现了上下文切换</li><li>线程B执行了，但是这个线程先锁2.lock()了，因为此时2.lock还没有被锁，所以2.lock()成功，线程B要去执行1.lock()</li><li>此时此刻，死锁产生了</li><li>线程A因为拿不到2.lock(),流程走不下去，所以1.不能unlock()</li><li>线程B因为拿不到1.lock(),流程走不下去，所以2.不能unlock()</li></ol><h3 id="死锁的一般解决方案"><a href="#死锁的一般解决方案" class="headerlink" title="死锁的一般解决方案"></a>死锁的一般解决方案</h3><p>只要保证这两个互斥量上锁的顺序一致就不会死锁</p><h3 id="std-lock-函数模板"><a href="#std-lock-函数模板" class="headerlink" title="std::lock()函数模板"></a>std::lock()函数模板</h3><p><code>std::lock(my_mutex1,my_mutex2);</code></p><ul><li>一次锁住两个或以上的互斥量</li><li>不存在因为多个线程中因为锁的顺序问题产生的死锁</li><li>如果互斥量中有一个没锁住，它就在那等着，等到所有的互斥量都锁柱，它才会继续往下走(返回)</li><li>要么两个互斥量都锁柱，要么都没锁柱。如果只锁了一个，另外一个没锁成功，则它立即把已经锁住的解锁</li></ul><h3 id="std-adopt-lock"><a href="#std-adopt-lock" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h3><ul><li>std::adopt_lock是个结构体对象,起标记作用，表示这个互斥量已经lock(),不需要在std::lock_guard<a href="std::mutex">std::mutex</a>里面对对象进行再次lock()了;<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::lock_guard&lt;mutex&gt; my_guard1(my_mutex1,std::adopt_lock);</span><br><span class="line">std::lock_guard&lt;mutex&gt; my_guard2(my_mutex2,std::adopt_lock);</span><br></pre></td></tr></tbody></table></figure><h3 id="Read-Write"><a href="#Read-Write" class="headerlink" title="Read_Write"></a>Read_Write</h3><blockquote><p>读者写者是一个非常著名的同步问题。读者写者问题描述非常简单，有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者在读文件时写者也不去能写文件。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;mutex&gt;</span><br><span class="line">#include&lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">mutex Write_mutex;</span><br><span class="line">list&lt;char&gt; buffer_area;</span><br><span class="line">queue&lt;int&gt; Read_queue;//读者队列</span><br><span class="line"></span><br><span class="line">void Write()</span><br><span class="line">{</span><br><span class="line">while (1)</span><br><span class="line">{</span><br><span class="line">if (Read_queue.empty())//如果读者队列为空，写者才能开始写</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "写者写文件" &lt;&lt; endl;</span><br><span class="line">Write_mutex.lock();//写者写的时候上锁，读者不能读</span><br><span class="line">buffer_area.push_back('#');</span><br><span class="line">Write_mutex.unlock();//写完解锁</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">void Read(int k)</span><br><span class="line">{</span><br><span class="line">while (1)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "读者" &lt;&lt; k &lt;&lt; "读文件" &lt;&lt; buffer_area.size() &lt;&lt; endl;</span><br><span class="line">int *q = new int(1);</span><br><span class="line">Read_queue.push(*q);//加入读者队列</span><br><span class="line">Write_mutex.lock();//读者读时上锁</span><br><span class="line">Write_mutex.unlock();//读完解锁</span><br><span class="line">delete q;</span><br><span class="line">Read_queue.pop();//读完退出读者队列</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">//可以添加读者</span><br><span class="line">thread myReader1(Read,1);//读者1</span><br><span class="line">thread myReader2(Read,2);//读者2</span><br><span class="line">thread myReader3(Read,3);//读者3</span><br><span class="line">thread myWriter(Write);</span><br><span class="line"></span><br><span class="line">myWriter.detach();</span><br><span class="line">myReader1.detach();</span><br><span class="line">myReader2.detach();</span><br><span class="line">myReader3.detach();</span><br><span class="line">Sleep(1000);</span><br><span class="line">return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="2021/05/22/%E5%BC%82%E5%B8%B8/"/>
      <url>2021/05/22/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a><a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">异常</a></h2><p>抛出异常</p><blockquote><p>您可以使用 throw 语句在代码块中的任何地方抛出异常。throw语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double division(int a, int b)</span><br><span class="line">{</span><br><span class="line">   if( b == 0 )</span><br><span class="line">   {</span><br><span class="line">      throw "Division by zero condition!";</span><br><span class="line">   }</span><br><span class="line">   return (a/b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>捕获异常</p><blockquote><p>catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由catch关键字后的括号内的异常声明决定的。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">{</span><br><span class="line">   // 保护代码</span><br><span class="line">}catch( ExceptionName e )</span><br><span class="line">{</span><br><span class="line">  // 处理 ExceptionName 异常的代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">double division(int a, int b)</span><br><span class="line">{</span><br><span class="line">   if( b == 0 )</span><br><span class="line">   {</span><br><span class="line">      throw "Division by zero condition!";</span><br><span class="line">   }</span><br><span class="line">   return (a/b);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">{</span><br><span class="line">   int x = 50;</span><br><span class="line">   int y = 0;</span><br><span class="line">   double z = 0;</span><br><span class="line"> </span><br><span class="line">   try {</span><br><span class="line">     z = division(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   }catch (const char* msg) {</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>运行结果</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Division by zero condition!</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="2021/05/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2021/05/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><blockquote><p><a href="http://c.biancheng.net/view/7909.html">unique_ptr</a></p></blockquote><ul><li>同一时刻只能有一个 unique_ptr 指向给对象</li><li>unique_ptr 指针的生命周期从创建时开始，直到离开作用域。离开作用域时，若其指向对象，则其所指对象销毁</li><li>unique_ptr 的使用能够包括：</li></ul><ol><li>为动态申请的内存提供异常安全</li><li>将动态申请内存的所有权传递给某个函数</li><li>从某个函数返回动态申请内存的所有权</li><li>在容器中保存指针</li><li>所有auto_ptr具有的功能<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    {</span><br><span class="line">        std::unique_ptr&lt;int&gt; uptr(new int(10));  //绑定动态对象</span><br><span class="line">        //std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能賦值</span><br><span class="line">        //std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷貝</span><br><span class="line">        std::unique_ptr&lt;int&gt; uptr2 = std::move(uptr); //轉換所有權</span><br><span class="line">        uptr2.release(); //释放所有权</span><br><span class="line">    }</span><br><span class="line">    //超過uptr的作用域，內存釋放</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="http://c.biancheng.net/view/7898.html">shared_ptr</a></p></blockquote></li></ol><ul><li><p>shared_ptr (共享资源的只能指针)被用来表示共享的拥有权。也就是说两段代码都需要访问一些数据，而他们又都没有独占该数据的所有权(从某种意义上来说就是该段代码负责销毁该对象)</p></li><li><p>shared_ptr 是一种计数指针。当引用计数变为0时，shared_ptr所指向的对象就会被删除。</p></li><li><p>在给shared_ptr分配内存时建议使用 make_shared 函数，这样最安全</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    {</span><br><span class="line">        int a = 10;</span><br><span class="line">        std::shared_ptr&lt;int&gt; ptra = std::make_shared&lt;int&gt;(a);</span><br><span class="line">        std::shared_ptr&lt;int&gt; ptra2(ptra); //copy</span><br><span class="line">        std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        int b = 20;</span><br><span class="line">        int *pb = &amp;a;</span><br><span class="line">        //std::shared_ptr&lt;int&gt; ptrb = pb;  //error</span><br><span class="line">        std::shared_ptr&lt;int&gt; ptrb = std::make_shared&lt;int&gt;(b);</span><br><span class="line">        ptra2 = ptrb; //assign</span><br><span class="line">        pb = ptrb.get(); //获取原始指针</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; ptrb.use_count() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="http://c.biancheng.net/view/7918.html">weak-ptr</a></p></blockquote></li><li><p>弱指针(weak pointer) ，指向一个已经用shared_ptr进行管理的对象</p></li><li><p>只有当对象存在的时候，才需要对其进行访问</p></li><li><p>可能被其他人删除释放，且在最后一次使用之后调用其析构函数(通常用于释放那些不具名的内存(anon-memory)资源</p></li><li><p>weak_ptr可以保存一个“弱引用”，引用一个已经用shared_ptr管理的对象。为了访问这个对象一个weak_ptr可以通过shared_ptr的构造函数或者是weak_ptr的成员函数lock()转化为一个shared_ptr。当最后一个指向这个对象的shared_ptr退出其生命周期并且这个对象被释放之后,将无法从指向这个对象的weak_ptr获得一个shared_ptr指针,shared_ptr的构造函数会抛出异常，而weak_ptr::lock也会返回一个空指针。</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    {</span><br><span class="line">        std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10);</span><br><span class="line">        std::cout &lt;&lt; sh_ptr.use_count() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::weak_ptr&lt;int&gt; wp(sh_ptr);</span><br><span class="line">        std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        if(!wp.expired()){</span><br><span class="line">            std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //get another shared_ptr</span><br><span class="line">            *sh_ptr = 100;</span><br><span class="line">            std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    //delete memory</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="2021/05/22/STL/"/>
      <url>2021/05/22/STL/</url>
      
        <content type="html"><![CDATA[<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a><a href="http://c.biancheng.net/stl/">STL</a></h2><blockquote><p>Standard Template Library</p></blockquote><table><thead><tr><th>类别</th><th>解释</th></tr></thead><tbody><tr><td>容器(containers)</td><td>特殊的数据结构，实现了数组链表队列等等，实质是模板类</td></tr><tr><td>迭代器(iterators)</td><td>一种复杂的指针，可以通过其读写容器中的对象，实质是运算符重载</td></tr><tr><td>空间配置器(allocator)</td><td>容器的空间配置管理的模板类</td></tr><tr><td>配接器(adapters)</td><td>用来修饰容器、仿函数、迭代器接口</td></tr><tr><td>算法(algorithms)</td><td>读写容器对象的逻辑算法：排序，便利，查找，等等实质是模板函数</td></tr><tr><td>仿函数(functors)</td><td>类似函数，通过重载()运算符来模拟函数行为的类</td></tr></tbody></table><blockquote><h3 id="STL-容器种类和功能"><a href="#STL-容器种类和功能" class="headerlink" title="STL 容器种类和功能"></a>STL 容器种类和功能</h3></blockquote><table><thead><tr><th>类别</th><th>解释</th></tr></thead><tbody><tr><td>序列容器</td><td>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td></tr><tr><td>排序容器</td><td>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td></tr><tr><td>哈希容器</td><td>C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td></tr></tbody></table><blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote><p>迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。</p><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。</p><blockquote><p>输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。</p></blockquote><ol><li><p>==前向迭代器（forward iterator）==<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p></li><li><p>==双向迭代器（bidirectional iterator）==<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p></li><li><p>==随机访问迭代器（random access iterator）==<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p></li></ol><ul><li>p+=i：使得 p 往后移动 i 个元素。</li><li>p-=i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><h3 id="C-11-标准中不同容器指定使用的迭代器类型。"><a href="#C-11-标准中不同容器指定使用的迭代器类型。" class="headerlink" title="C++ 11 标准中不同容器指定使用的迭代器类型。"></a>C++ 11 标准中不同容器指定使用的迭代器类型。</h3><table><thead><tr><th>容器</th><th>对应的迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set / multiset</td><td>双向迭代器</td></tr><tr><td>map / multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map / unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set / unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><h3 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h3><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式</p><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator  迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator  迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator  迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator  迭代器名;</td></tr></tbody></table><h3 id="遍历-vector-容器。"><a href="#遍历-vector-容器。" class="headerlink" title="//遍历 vector 容器。"></a>//遍历 vector 容器。</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    vector&lt;int&gt; v{1,2,3,4,5,6,7,8,9,10}; //v被初始化成有10个元素</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; i = 0; i &lt; v.size(); ++i)</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt;" ";</span><br><span class="line">    //创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; "第二种遍历方法：" &lt;&lt; endl;</span><br><span class="line">    vector&lt;int&gt;::iterator i;</span><br><span class="line">    //用 != 比较两个迭代器</span><br><span class="line">    for (i = v.begin(); i != v.end(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; " ";</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; "第三种遍历方法：" &lt;&lt; endl;</span><br><span class="line">    for (i = v.begin(); i &lt; v.end(); ++i) //用 &lt; 比较两个迭代器</span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; " ";</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; "第四种遍历方法：" &lt;&lt; endl;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    while (i &lt; v.end()) </span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; " ";</span><br><span class="line">        i += 2; // 随机访问迭代器支持 "+= 整数"  的操作</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2021/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2021/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="各种内部排序方法比较"><a href="#各种内部排序方法比较" class="headerlink" title="各种内部排序方法比较"></a>各种内部排序方法比较</h2><table><thead><tr><th>类别</th><th>排序</th><th>best</th><th>normal</th><th>worst</th><th>辅助空间</th><th>稳定性</th><th>比较次数</th><th>交换次数</th></tr></thead><tbody><tr><td>插入</td><td>插入排序</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>n-1,n(n-1)/2</td><td>0,n(n-1)/2</td></tr><tr><td>插入</td><td>希尔排序</td><td>O(n)</td><td>O(n^1.3)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>?</td><td>?</td></tr><tr><td>选择</td><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>n(n-1)/2</td><td>0,n-1</td></tr><tr><td>选择</td><td>堆排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>不稳定</td><td>nlog2n</td><td>?</td></tr><tr><td>交换</td><td>冒泡排序</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>n-1,n(n-1)/2</td><td>0,n(n-1)/2</td></tr><tr><td>交换</td><td>快速排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n²)</td><td>O(nlog2n)</td><td>不稳定</td><td>nlog2n,n(n-1)/2</td><td>?</td></tr><tr><td></td><td>归并排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n)</td><td>稳定</td><td>nlog2n/2</td><td>?</td></tr><tr><td></td><td>基数排序</td><td>O(d(n+rd)</td><td>O(d(n+rd))</td><td>O(d(n+rd))</td><td>O(rd+n)</td><td>稳定</td><td>?</td><td>?</td></tr></tbody></table><p>注：基数排序中d代表长度，r代表关键字基数，n代表关键字个数</p><h2 id="背景及字体颜色"><a href="#背景及字体颜色" class="headerlink" title="背景及字体颜色"></a>背景及字体颜色</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">//背景颜色： </span><br><span class="line">//0 黑色  </span><br><span class="line">//1 蓝色 </span><br><span class="line">//2 绿色 </span><br><span class="line">//3 湖蓝色 </span><br><span class="line">//4 红色 </span><br><span class="line">//5 紫色 </span><br><span class="line">//6 黄色</span><br><span class="line">//7 白色</span><br><span class="line">//8 灰色</span><br><span class="line">//9 淡蓝色</span><br><span class="line">void BackGround(unsigned int ForeColor=7,unsigned int BackGroundColor=0) </span><br><span class="line">{</span><br><span class="line">    HANDLE handle=GetStdHandle(STD_OUTPUT_HANDLE);  </span><br><span class="line">    SetConsoleTextAttribute(handle,ForeColor+BackGroundColor*0x10);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="HuffmanTreeCode"><a href="#HuffmanTreeCode" class="headerlink" title="HuffmanTreeCode"></a>HuffmanTreeCode</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 1000 //哈夫曼树最大结点个数</span><br><span class="line">#define MAXW 1000 //权值最大</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//哈夫曼树结点结构</span><br><span class="line">typedef struct HNode</span><br><span class="line">{</span><br><span class="line">char data; //数据,非叶节点为NULL</span><br><span class="line">double weight;//权重</span><br><span class="line">int parent;//双亲，-1表示没有双亲，即根节点</span><br><span class="line">int lchild;//左孩子，数组下标,-1表示无左孩子，即叶节点</span><br><span class="line">int rchild;//右孩子</span><br><span class="line">}Hnode;</span><br><span class="line"></span><br><span class="line">//编码结构</span><br><span class="line">typedef struct HuffmanCodeNode</span><br><span class="line">{</span><br><span class="line">char data; //数据</span><br><span class="line">string code;//该字符编码</span><br><span class="line">}HuffmanCodenode;</span><br><span class="line"></span><br><span class="line">//两个最小结点下标</span><br><span class="line">typedef struct minnodes</span><br><span class="line">{</span><br><span class="line">int m1;//两者更小权值结点下标</span><br><span class="line">int m2;</span><br><span class="line">bool flag;//若找到则为true,否则为false，false说明仅有一个结点</span><br><span class="line">}Minnodes;</span><br><span class="line"></span><br><span class="line">//辅助标志数组 标记该结点为根的树是否已加入哈夫曼树</span><br><span class="line">bool flag[MAX] = { false };</span><br><span class="line"></span><br><span class="line">Hnode HuffmanTree[MAX];//哈夫曼树</span><br><span class="line">HuffmanCodeNode HuffmanCode[MAX];//哈夫曼编码数组</span><br><span class="line"></span><br><span class="line">//选择两棵最小权值的树 参数max，当前有权值结点下标+1</span><br><span class="line">minnodes Select(int max)</span><br><span class="line">{</span><br><span class="line">double min = MAXW;</span><br><span class="line">minnodes mins;</span><br><span class="line">mins.m2 = -1;</span><br><span class="line"></span><br><span class="line">//查找第一个最小权值的结点下标</span><br><span class="line">for (int i = 0; i &lt; max; i++)</span><br><span class="line">{</span><br><span class="line">if (!flag[i] &amp;&amp; HuffmanTree[i].weight &lt; min)//未加入哈夫曼树,权值更小</span><br><span class="line">{</span><br><span class="line">min = HuffmanTree[i].weight;//更新最小权值</span><br><span class="line">mins.m1 = i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">flag[mins.m1] = true;//将结点加入哈夫曼树</span><br><span class="line">min = MAXW;</span><br><span class="line"></span><br><span class="line">//查找第二个最小权值结点下标，可能不存在</span><br><span class="line">for (int i = 0; i &lt; max; i++)</span><br><span class="line">{</span><br><span class="line">if (!flag[i] &amp;&amp; HuffmanTree[i].weight &lt; min)//未加入哈夫曼树,权值更小</span><br><span class="line">{</span><br><span class="line">min = HuffmanTree[i].weight;//更新最小权值</span><br><span class="line">mins.m2 = i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">flag[mins.m2] = true;//将结点加入哈夫曼树</span><br><span class="line">if (-1 == mins.m2)//仅剩余一个结点未加入哈夫曼树</span><br><span class="line">{</span><br><span class="line">mins.flag = false;//未找到两棵最小权值树</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">mins.flag = true;</span><br><span class="line">}</span><br><span class="line">return mins;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//打印哈夫曼树</span><br><span class="line">void PrintHuffmanTree(int max)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "下标\t" &lt;&lt; "数据\t" &lt;&lt; "权重\t" &lt;&lt; "双亲\t" &lt;&lt; "左孩子\t" &lt;&lt; "右孩子" &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; max; i++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].data &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].weight &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].parent &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].lchild &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].rchild &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//打印编码</span><br><span class="line">void PrintHuffmanCode(int n)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "哈夫曼编码："&lt;&lt;endl;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; HuffmanCode[i].data &lt;&lt; ":" &lt;&lt; HuffmanCode[i].code &lt;&lt; endl;;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建哈夫曼树</span><br><span class="line">void CreateHuffmanTree()</span><br><span class="line">{</span><br><span class="line">int n;//字符个数，即哈夫曼树叶节点个数</span><br><span class="line">minnodes mins;</span><br><span class="line">cout &lt;&lt; "请输入字符个数：" &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; "请输入字符及权值：" &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">cin &gt;&gt; HuffmanTree[i].data &gt;&gt; HuffmanTree[i].weight;</span><br><span class="line">HuffmanTree[i].lchild = -1; HuffmanTree[i].rchild = -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int i = n;</span><br><span class="line">for (;; i++)</span><br><span class="line">{</span><br><span class="line">mins = Select(i);//找到两棵根权值最小的树</span><br><span class="line">if (mins.flag == false)//仅剩余一棵树时跳出</span><br><span class="line">{</span><br><span class="line">HuffmanTree[mins.m1].parent = -1;</span><br><span class="line">break;</span><br><span class="line">}</span><br><span class="line">HuffmanTree[i].weight = HuffmanTree[mins.m1].weight + HuffmanTree[mins.m2].weight;//新加入哈夫曼树结点为两个结点权值之和</span><br><span class="line">HuffmanTree[i].data = ' ';</span><br><span class="line">HuffmanTree[mins.m1].parent = i;                                //两个权值最小结点双亲为新加入结点</span><br><span class="line">HuffmanTree[mins.m2].parent = i;</span><br><span class="line">HuffmanTree[i].lchild = mins.m1;//左小又大</span><br><span class="line">HuffmanTree[i].rchild = mins.m2;</span><br><span class="line">}</span><br><span class="line">PrintHuffmanTree(i);//打印哈夫曼树</span><br><span class="line">}</span><br><span class="line">//哈夫曼编码</span><br><span class="line">void Code()</span><br><span class="line">{</span><br><span class="line">int i = 0;</span><br><span class="line">for (;; i++)//给所有叶子结点编码</span><br><span class="line">{</span><br><span class="line">int j = i;</span><br><span class="line">string str = "";</span><br><span class="line">HuffmanCode[i].data = HuffmanTree[i].data;//复制数据</span><br><span class="line">while (-1 != HuffmanTree[j].parent)//从叶节点找到根</span><br><span class="line">{</span><br><span class="line">if (HuffmanTree[HuffmanTree[j].parent].lchild == j)//左0右1</span><br><span class="line">{</span><br><span class="line">str += '0';</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">str += '1';</span><br><span class="line">}</span><br><span class="line">j = HuffmanTree[j].parent;</span><br><span class="line">}</span><br><span class="line">reverse(str.begin(), str.end());//逆序</span><br><span class="line">HuffmanCode[i].code = str;              //保存至编码</span><br><span class="line">if (HuffmanTree[i].lchild == -1 &amp;&amp; HuffmanTree[i].rchild == -1)continue;//非叶子不编码</span><br><span class="line">else break;</span><br><span class="line">}</span><br><span class="line">PrintHuffmanCode(i);</span><br><span class="line">}</span><br><span class="line">//哈夫曼树解码 从根开始，左0右1，直至叶节点</span><br><span class="line">void Encode()</span><br><span class="line">{</span><br><span class="line">string s;</span><br><span class="line">int root = 0;//记录根节点的下标</span><br><span class="line">cout &lt;&lt; "请输入01字符串:" &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">while (HuffmanTree[root].parent != -1) root++;</span><br><span class="line">int j = root;</span><br><span class="line">for (int i = 0; i &lt; s.size(); i++)//遍历输入的01串</span><br><span class="line">{</span><br><span class="line">if ('0' == s[i])</span><br><span class="line">{</span><br><span class="line">j = HuffmanTree[j].lchild;</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">j = HuffmanTree[j].rchild;</span><br><span class="line">}</span><br><span class="line">if (HuffmanTree[j].lchild == -1 &amp;&amp; HuffmanTree[j].rchild == -1)//到达叶节点</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; HuffmanTree[j].data;</span><br><span class="line">j = root;//返回根节点继续</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">//计算WPL</span><br><span class="line">void WPL()</span><br><span class="line">{</span><br><span class="line">double WPL = 0;</span><br><span class="line">for (int i = 0;; i++)</span><br><span class="line">{</span><br><span class="line">if (HuffmanTree[i].lchild != -1 || HuffmanTree[i].rchild != -1)break;</span><br><span class="line">WPL += HuffmanTree[i].weight * HuffmanCode[i].code.length();//权值×路径长度（编码长度）</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; "WPL:" &lt;&lt; WPL &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//主函数</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">int choice = 0;</span><br><span class="line">cout &lt;&lt; "----------1.创建哈夫曼树----------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------2.编码--------------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------3.解码--------------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------4.WPL---------------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------5.退出--------------" &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "-请输入菜单序号：" &lt;&lt; endl; </span><br><span class="line">while (1)</span><br><span class="line">{</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line">switch (choice)</span><br><span class="line">{</span><br><span class="line">case 1:CreateHuffmanTree(); break;</span><br><span class="line">case 2:Code(); break;</span><br><span class="line">case 3:Encode(); break;</span><br><span class="line">case 4:WPL(); break;</span><br><span class="line">case 5:break;</span><br><span class="line">default:</span><br><span class="line">cout &lt;&lt; "输入错误：" &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="病毒感染检测（BF算法）"><a href="#病毒感染检测（BF算法）" class="headerlink" title="病毒感染检测（BF算法）"></a>病毒感染检测（BF算法）</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(<span class="keyword">const</span> string&amp; str1, <span class="keyword">const</span> string&amp; str2, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2 = str2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (str1[i] == str2[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= len2)</span><br><span class="line">        <span class="keyword">return</span> i - len2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-99</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str2 &gt;&gt; str1)</span><br><span class="line">    {</span><br><span class="line">        str1 = str1 + str1;</span><br><span class="line">        <span class="keyword">if</span> (str1 == <span class="string">"0"</span> &amp;&amp; str2 == <span class="string">"0"</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">Index_BF</span>(str1, str2, pos);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-99</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">"NO"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"YES"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="病毒感染检测（KMP算法）"><a href="#病毒感染检测（KMP算法）" class="headerlink" title="病毒感染检测（KMP算法）"></a>病毒感染检测（KMP算法）</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(string str2,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;str2.<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||str2[i]==str2[j])</span><br><span class="line">        {</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(str2[i]!=str2[j])</span><br><span class="line">                next[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i]=next[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(string &amp;str1,string &amp;str2,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=pos;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">255</span>];</span><br><span class="line">    <span class="built_in">get_next</span>(str2,next);</span><br><span class="line">    <span class="keyword">int</span> len1=str1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2=str2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||str1[i]==str2[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            j=next[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=len2)</span><br><span class="line">            <span class="keyword">return</span> i-len2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>    ;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt;str2&gt;&gt;str1)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(str1==<span class="string">"0"</span>&amp;&amp;str2==<span class="string">"0"</span>)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="built_in">kmp</span>(str1,str2,pos);</span><br><span class="line">    <span class="keyword">if</span>(result!=<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">"YES"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">"NO"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="算符表达式求值"><a href="#算符表达式求值" class="headerlink" title="算符表达式求值"></a>算符表达式求值</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"><span class="keyword">char</span> priority[<span class="number">7</span>][<span class="number">7</span>]=</span><br><span class="line">{ </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'='</span>,<span class="string">'0'</span>},   <span class="comment">// "="表示左右括号相遇，括号内运算已完成 </span></span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'0'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'0'</span>,<span class="string">'='</span>}    <span class="comment">// "=" 表示整个表达式求值完毕 </span></span><br><span class="line">};                               <span class="comment">//  "0"表示不可能出现这种情况 ( 语法错误 ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Precede 用于判断运算符栈栈顶运算符 a1 与读入运算符 a2 之间的优先关系函数 </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Procede</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>{   <span class="comment">// 建立 pre[][] 到 运算符间的映射关系 </span></span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(a){  </span><br><span class="line">        <span class="keyword">case</span><span class="number">'</span>+<span class="string">':i=0;break;  </span></span><br><span class="line"><span class="string">        case'</span>-<span class="string">':i=1;break;  </span></span><br><span class="line"><span class="string">        case'</span>*<span class="string">':i=2;break;  </span></span><br><span class="line"><span class="string">        case'</span>/<span class="string">':i=3;break;  </span></span><br><span class="line"><span class="string">        case'</span>(<span class="string">':i=4;break;  </span></span><br><span class="line"><span class="string">        case'</span>)<span class="string">':i=5;break;  </span></span><br><span class="line"><span class="string">        case'</span>#<span class="string">':i=6;break;</span></span><br><span class="line"><span class="string">    }  </span></span><br><span class="line"><span class="string">    switch(b){  </span></span><br><span class="line"><span class="string">        case'</span>+<span class="string">':j=0;break;  </span></span><br><span class="line"><span class="string">        case'</span>-<span class="string">':j=1;break;  </span></span><br><span class="line"><span class="string">        case'</span>*<span class="string">':j=2;break;  </span></span><br><span class="line"><span class="string">        case'</span>/<span class="string">':j=3;break;  </span></span><br><span class="line"><span class="string">        case'</span>(<span class="string">':j=4;break;  </span></span><br><span class="line"><span class="string">        case'</span>)<span class="string">':j=5;break;  </span></span><br><span class="line"><span class="string">        case'</span>#<span class="string">':j=6;break;  </span></span><br><span class="line"><span class="string">    }  </span></span><br><span class="line"><span class="string">    return priority[i][j];  </span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">int Operate(int m,int n,char x){  </span></span><br><span class="line"><span class="string">    if(x=='</span>+<span class="string">')  </span></span><br><span class="line"><span class="string">    return m+n;  </span></span><br><span class="line"><span class="string">    if(x=='</span>-<span class="string">')  </span></span><br><span class="line"><span class="string">    return n-m;  </span></span><br><span class="line"><span class="string">    if(x=='</span>*<span class="string">')  </span></span><br><span class="line"><span class="string">    return m*n;  </span></span><br><span class="line"><span class="string">    if(x=='</span>/<span class="string">')  </span></span><br><span class="line"><span class="string">    return n/m;  </span></span><br><span class="line"><span class="string">}  </span></span><br><span class="line"><span class="string">// EvaluuateExpression-reduced</span></span><br><span class="line"><span class="string">int main(){</span></span><br><span class="line"><span class="string">    stack &lt;int&gt; OPND;  // Operand stack</span></span><br><span class="line"><span class="string">    stack &lt;char&gt; OPTR;  // Operator stack</span></span><br><span class="line"><span class="string">OPTR.push('</span>#<span class="string">');//</span></span><br><span class="line"><span class="string">    char ss[2]="#";//尾部有\0 </span></span><br><span class="line"><span class="string">    char s[100];</span></span><br><span class="line"><span class="string">    cout&lt;&lt;"输入表达式："&lt;&lt;endl; </span></span><br><span class="line"><span class="string">    cin&gt;&gt;s;</span></span><br><span class="line"><span class="string">    strcat(s,ss);// 运算式尾部加 "#"--结束运算符 </span></span><br><span class="line"><span class="string">    char c=s[0];</span></span><br><span class="line"><span class="string">    int i=1;</span></span><br><span class="line"><span class="string">    while(c!='</span>#<span class="string">'||OPTR.top()!='</span>#<span class="string">'){  //表达式未读完或者运算未完 </span></span><br><span class="line"><span class="string">        int y=0;  </span></span><br><span class="line"><span class="string">        if(c&gt;='</span><span class="number">0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>){    </span><br><span class="line">            <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>){  <span class="comment">// 读入连续的数字 </span></span><br><span class="line">                y=y*<span class="number">10</span>+(c-<span class="string">'0'</span>);  </span><br><span class="line">                c=s[i++];  </span><br><span class="line">            }  </span><br><span class="line">            OPND.<span class="built_in">push</span>(y);  <span class="comment">// 把读进的数字入数字栈 </span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(<span class="built_in">Procede</span>(OPTR.<span class="built_in">top</span>(),c))  </span><br><span class="line">            {  </span><br><span class="line">                <span class="keyword">case</span><span class="number">'</span>&lt;<span class="string">':  //栈顶元素优先权低 </span></span><br><span class="line"><span class="string">                    OPTR.push(c);  </span></span><br><span class="line"><span class="string">                    c=s[i++];  </span></span><br><span class="line"><span class="string">                    break;  </span></span><br><span class="line"><span class="string">                case'</span>=<span class="string">':  </span></span><br><span class="line"><span class="string">                    OPTR.pop();  // 脱括号 </span></span><br><span class="line"><span class="string">                    c=s[i++];  // 读入下一个字符 </span></span><br><span class="line"><span class="string">                    break;  </span></span><br><span class="line"><span class="string">                case'</span>&gt;<span class="string">':  //退栈并将运算结果入栈 </span></span><br><span class="line"><span class="string">                    char x=OPTR.top();OPTR.pop();  </span></span><br><span class="line"><span class="string">                    int m=OPND.top();OPND.pop();  </span></span><br><span class="line"><span class="string">                    int n=OPND.top();OPND.pop();  </span></span><br><span class="line"><span class="string">                    OPND.push(Operate(m,n,x));  </span></span><br><span class="line"><span class="string">                    break;    </span></span><br><span class="line"><span class="string">            } </span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    cout&lt;&lt;OPND.top();</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Josephus"><a href="#Josephus" class="headerlink" title="Josephus"></a>Josephus</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">}node;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//创建n个数据 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//初始化节点 </span></span><br><span class="line">node* p = <span class="literal">NULL</span>;</span><br><span class="line">node* head=<span class="literal">NULL</span>;</span><br><span class="line">node* s=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">head = <span class="keyword">new</span> node;</span><br><span class="line">p = head;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> ( i &lt;= n )</span><br><span class="line">{</span><br><span class="line">s = <span class="keyword">new</span> node;<span class="comment">//创建新节点 </span></span><br><span class="line">s-&gt;data = i++;</span><br><span class="line">p-&gt;next = s;<span class="comment">//链接s </span></span><br><span class="line">p = s;<span class="comment">//p指向s </span></span><br><span class="line">}</span><br><span class="line">s-&gt;next = head-&gt;next;<span class="comment">//首尾相连构成循环链表 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n, m, i,count;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"n="</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"m="</span>;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">node* p = <span class="built_in">create</span>(n);<span class="comment">//建立循环链表同时p指向首元  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != p-&gt;next)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line">p = p-&gt;next;<span class="comment">//p指向m-1个next </span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line"></span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span>(count%<span class="number">8</span>==<span class="number">0</span>)cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;<span class="comment">//p指向下一个节点</span></span><br><span class="line"></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统"></a>图书管理系统</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    string isbn;<span class="comment">//ISBN</span></span><br><span class="line">    string name;<span class="comment">//书名</span></span><br><span class="line">    <span class="keyword">double</span> price;<span class="comment">//定价</span></span><br><span class="line">} Elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    Book data; <span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//结点的指针域</span></span><br><span class="line">}*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p,r;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//先建立一个带头结点的空链表</span></span><br><span class="line">r=L; <span class="comment">//尾指针r指向头结点 </span></span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">"book.txt"</span>, ios::out | ios::in|ios::app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到相关文件，无法打开！"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;!file.<span class="built_in">eof</span>();)</span><br><span class="line">    {</span><br><span class="line">        p = <span class="keyword">new</span> LNode; <span class="comment">//生成新结点*p</span></span><br><span class="line">        file &gt;&gt; p-&gt;data.isbn &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price; <span class="comment">//输入元素值赋给新结点*p的数据域</span></span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = p; <span class="comment">//将新结点*p插入到尾结点*r之后</span></span><br><span class="line">r=p;<span class="comment">//r指向新的尾结点p </span></span><br><span class="line">        length++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    L = <span class="keyword">new</span> LNode; <span class="comment">//生成新结点作为头结点，用头指针L指向头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">//头结点的指针域置空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, Book &amp;e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">//初始化，p指向第一个结点，j为计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i &amp;&amp; p)   <span class="comment">//顺链域向后扫描，直到p指向第i个元素或p为空</span></span><br><span class="line">    {</span><br><span class="line">        p = p-&gt;next; <span class="comment">//p指向下一个结点</span></span><br><span class="line">        ++j; <span class="comment">//计数器j相应加1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//i值不合法i＞n或i&lt;=0</span></span><br><span class="line"></span><br><span class="line">    e = p-&gt;data; <span class="comment">//取第i个结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, string e)</span> <span class="comment">//在带头结点的单链表L中查找值为e的元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-&gt;next;<span class="comment">//初始化，p指向首元结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data.name != e) <span class="comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span></span><br><span class="line">        p = p-&gt;next; <span class="comment">//p指向下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//查找成功返回值为e的结点地址p，查找失败p为NULL</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, Book &amp;e)</span> <span class="comment">//在带头结点的单链表L中第i个位置插入值为e的新结点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    LinkList p, s;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i - <span class="number">1</span>)  <span class="comment">//查找第i-1个结点，p指向该结点</span></span><br><span class="line">    {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//i＞n+1或者i＜1</span></span><br><span class="line"></span><br><span class="line">    s = <span class="keyword">new</span> LNode; <span class="comment">//生成新结点*s</span></span><br><span class="line">    s-&gt;data = e; <span class="comment">//将结点*s的数据域置为e</span></span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">//将结点*s的指针域指向结点ai</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">//将结点*p的指针域指向结点*s</span></span><br><span class="line"></span><br><span class="line">    ++length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i)</span><span class="comment">//在带头结点的单链表L中，删除第i个位置</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p, q;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next) &amp;&amp; (j &lt; i - <span class="number">1</span>))  <span class="comment">//查找第i-1个结点，p指向该结点</span></span><br><span class="line">    {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || (j &gt; i - <span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//当i&gt;n或i&lt;1时，删除位置不合理</span></span><br><span class="line"></span><br><span class="line">    q = p-&gt;next; <span class="comment">//临时保存被删结点的地址以备释放</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">//改变删除结点前驱结点的指针域</span></span><br><span class="line">    <span class="keyword">delete</span> q; <span class="comment">//释放删除结点的空间</span></span><br><span class="line">    --length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示所有图书</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showdata</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"当前记录为空"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        p = L-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; <span class="string">"书名："</span> &lt;&lt; p-&gt;data.name &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">"ISBN："</span> &lt;&lt; p-&gt;data.isbn &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">"价格："</span> &lt;&lt; p-&gt;data.price &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"*************************"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  1、建立图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  2、输入图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  3、图书取值  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  4、查找图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  5、插入图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  6、图书删除  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  7、所有图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  0、退出 BMS  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*************************"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    string name;</span><br><span class="line">    Book e;</span><br><span class="line">    LinkList L, p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(select)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">InitList</span>(L))</span><br><span class="line">                cout &lt;&lt; <span class="string">"成功建立链表"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">CreateList</span>(L, length);</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入信息完毕"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入取值的位置:"</span>;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">GetElem</span>(L, a, e))</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; <span class="string">"查找成功"</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"第"</span> &lt;&lt; a &lt;&lt; <span class="string">"本图书的信息是："</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"ISBN："</span>&lt;&lt; e.isbn &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"书名："</span>&lt;&lt; e.name &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"价格："</span>&lt;&lt; e.price &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"查找失败"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入所要查找书名:"</span>;</span><br><span class="line">            cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">LocateElem</span>(L, name) != <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; <span class="string">"查找成功"</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"该书对应的信息为："</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"ISBN："</span>&lt;&lt; <span class="built_in">LocateElem</span>(L, name)-&gt;data.isbn&lt;&lt;endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"书名："</span>&lt;&lt; <span class="built_in">LocateElem</span>(L, name)-&gt;data.name&lt;&lt;endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"价格："</span>&lt;&lt; <span class="built_in">LocateElem</span>(L, name)-&gt;data.price&lt;&lt;endl;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"查找失败《"</span> &lt;&lt; name &lt;&lt; <span class="string">"》没有找到"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的位置："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; b;</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的书的名字："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; e.name;</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的书的ISBN："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; e.isbn;</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的书的价格："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; e.price;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListInsert</span>(L, b, e))</span><br><span class="line">            {   </span><br><span class="line">ofstream outlife;</span><br><span class="line">    outlife.<span class="built_in">open</span>(<span class="string">"book.txt"</span>,ios::out | ios::in |ios::app);</span><br><span class="line">    outlife&lt;&lt;e.isbn&lt;&lt;endl;</span><br><span class="line">    outlife&lt;&lt;e.name&lt;&lt;endl;</span><br><span class="line">    outlife&lt;&lt;e.price&lt;&lt;endl;</span><br><span class="line">    outlife.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"插入成功"</span> &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"插入失败"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入所要删除的书籍的位置:"</span>;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListDelete</span>(L, c))</span><br><span class="line">                cout &lt;&lt; <span class="string">"删除成功!\n\n"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"删除失败!\n\n"</span>;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            p = L-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(p)</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; p-&gt;data.isbn &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; p-&gt;data.name &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; p-&gt;data.price &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"退出成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/17/hello-world/"/>
      <url>2021/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
