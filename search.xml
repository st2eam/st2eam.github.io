<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>images</title>
      <link href="2099/05/20/images/"/>
      <url>2099/05/20/images/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/r2e391.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> images </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Detour进行简单的Hook</title>
      <link href="2021/08/09/%E4%BD%BF%E7%94%A8Detour%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%9A%84Hook/"/>
      <url>2021/08/09/%E4%BD%BF%E7%94%A8Detour%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%9A%84Hook/</url>
      
        <content type="html"><![CDATA[<h1 id="Detours"><a href="#Detours" class="headerlink" title="Detours"></a>Detours</h1><h3 id="What-is-Detours"><a href="#What-is-Detours" class="headerlink" title="What is Detours"></a><a href="https://www.microsoft.com/en-us/research/project/detours/?from=http://research.microsoft.com/en-us/projects/detours/">What is Detours</a></h3><p>自己去看</p><h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h3><p>去GitHub下载源码: <a href="https://github.com/microsoft/detours">https://github.com/microsoft/detours</a></p><h4 id="1-解压"><a href="#1-解压" class="headerlink" title="1. 解压"></a>1. 解压</h4><h4 id="2-在开始菜单中找到"><a href="#2-在开始菜单中找到" class="headerlink" title="2. 在开始菜单中找到"></a>2. 在开始菜单中找到</h4><p><strong>x64 Native Tools Command Prompt for VS 2019</strong> 和 <strong>x86 Native Tools Command Prompt for VS 2019</strong>，这两个可以分别用来编译<strong>64位</strong>和<strong>32位</strong>的Detours.</p><p><img src="/images/20210809142451.png" alt="image"></p><h4 id="3-定位路径到解压的Detours文件夹的src目录下"><a href="#3-定位路径到解压的Detours文件夹的src目录下" class="headerlink" title="3. 定位路径到解压的Detours文件夹的src目录下"></a>3. 定位路径到解压的Detours文件夹的<strong>src</strong>目录下</h4><p><img src="/images/20210809142911.png" alt="image"></p><p>使用 nmake 输入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake /f Makefile</span><br></pre></td></tr></tbody></table></figure><p>之后在根目录生成<strong>bin.X64、lib.X64、include</strong>这三个文件夹。同理使用X86 Native Tools进行编译的话生成的是<strong>bin.X86、lib.X86、include</strong>这三个文件夹.</p><h4 id="4-准备工作"><a href="#4-准备工作" class="headerlink" title="4. 准备工作"></a>4. 准备工作</h4><ul><li>首先，在VS里创建一个C++的控制台项目，然后配置一下项目的<strong>包含目录</strong>和<strong>库目录</strong></li></ul><p><img src="/images/20210809143142.png" alt="image"></p><ul><li>添加相应的头文件</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"detours.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"detours.lib"</span>)</span></span><br></pre></td></tr></tbody></table></figure><h4 id="5-开始Hook"><a href="#5-开始Hook" class="headerlink" title="5. 开始Hook"></a>5. 开始Hook</h4><p>首先先声明要hook的两个函数的函数指针，这里是MessageBoxA和MessageBoxW。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (WINAPI* Old_MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) = MessageBoxA;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (WINAPI* Old_MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) = MessageBoxW;</span><br></pre></td></tr></tbody></table></figure><p>然后创建Hook后要对上述两个函数进行的操作：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">New_MessageBoxA</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Old_MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">"Hooked MessageBoxA"</span>, <span class="string">"Hooked MessageBoxA"</span>, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">New_MessageBoxW</span><span class="params">(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Old_MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L"Hooked MessageBoxW"</span>, <span class="string">L"Hooked MessageBoxW"</span>, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编写相应的Hook操作：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line"><span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line"><span class="built_in">DetourAttach</span>(&amp;(PVOID&amp;)Old_MessageBoxA, New_MessageBoxA);</span><br><span class="line"><span class="built_in">DetourAttach</span>(&amp;(PVOID&amp;)Old_MessageBoxW, New_MessageBoxW);</span><br><span class="line"><span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编写相应的DeHook操作:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line"><span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line"><span class="built_in">DetourDetach</span>(&amp;(PVOID&amp;)Old_MessageBoxA, New_MessageBoxA);</span><br><span class="line"><span class="built_in">DetourDetach</span>(&amp;(PVOID&amp;)Old_MessageBoxW, New_MessageBoxW);</span><br><span class="line"><span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后,在main函数里进行测试</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">"Hello World!"</span>, <span class="string">"MessageBoxA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L"Hello World!"</span>, <span class="string">L"MessageBoxW"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">Hook</span>();<span class="comment">//开始Hook</span></span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">"Hello World!"</span>, <span class="string">"MessageBoxA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L"Hello World!"</span>, <span class="string">L"MessageBoxW"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">DeHook</span>();<span class="comment">//解除Hook</span></span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">"Hello World!"</span>, <span class="string">"MessageBoxA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L"Hello World!"</span>, <span class="string">L"MessageBoxW"</span>, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统桌面目录的文件搜索工具</title>
      <link href="2021/08/01/%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7/"/>
      <url>2021/08/01/%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="系统桌面目录的文件搜索工具"><a href="#系统桌面目录的文件搜索工具" class="headerlink" title="系统桌面目录的文件搜索工具"></a>系统桌面目录的文件搜索工具</h1><h3 id="完成功能"><a href="#完成功能" class="headerlink" title="完成功能"></a>完成功能</h3><ol><li>完整实现基本功能<ul><li>包含桌面目录下的所有文件及文件夹</li><li>搜索及排序展示功能,包含程序图标、名称、路径、大小信息.</li><li>右键菜单，右键中菜单中包含启动和删除功能</li><li>程序启动后默认隐藏至系统托盘,通过 alt+空格 唤出，再次按下 alt+空格 隐藏；</li><li>关闭程序时隐藏自系统托盘,需要在系统托盘下右键退出才是真正结束程序</li><li>中文名称的程序支持通过拼音首字母进行混合搜索</li></ul></li><li>搜索速度达到毫秒级显示</li><li>有目录变化监控和更新机制</li><li>支持模糊匹配搜索,并进行排序</li><li>实现搜索关键字加粗高亮的功能</li><li>UI界面的设计及美化</li><li>搜索准确率优化等</li></ol><h4 id="暂未完成功能"><a href="#暂未完成功能" class="headerlink" title="暂未完成功能"></a>暂未完成功能</h4><ol><li>未完成后台加载数据库,以至于第一次打开时等待时间久</li><li>实现了但未应用字符串相似度排序算法,但实现了相似效果</li><li>或许可以使用map+list之类的数据结构存储使用内存缓存进行存储</li></ol><h3 id="运行结果展示"><a href="#运行结果展示" class="headerlink" title="运行结果展示"></a>运行结果展示</h3><p><img src="/images/20210731204126.png" alt="image"></p><p><img src="/images/20210731204502.png" alt="image"></p><h2 id="2021-07-26"><a href="#2021-07-26" class="headerlink" title="2021/07/26"></a>2021/07/26</h2><h4 id="开始构思实现"><a href="#开始构思实现" class="headerlink" title="开始构思实现"></a>开始构思实现</h4><p>最开始尝试使用listWidget控件作为主要的显示控件,以QStringList为数据存储.因为感觉listWidget自带的<code>addItems</code>函数以及setIcon等函数和QStringList的配合使用对工具实现非常的方便,而且可以添加自定义的Widget作为Items,作为之后的ui美化.但是经过测试对比发现以QStringList为数据存储进行筛选排序时运行速度缓慢不能达到要求.</p><p>之后改用对数据库支持较好的listView作为显示控件,但是listView只能显示第一列的数据,所以最后决定改用tableView作为显示的控件,用数据库进行存储.</p><h2 id="2021-07-27"><a href="#2021-07-27" class="headerlink" title="2021/07/27"></a>2021/07/27</h2><h3 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h3><p>今日的工作完成了在搜索栏输入关键字，快速搜索系统桌面目录里的文件和文件夹，展示在列表中，包含程序名称、路径、大小信息。支持模糊匹配搜索; 右键菜单,包含启动和删除功能</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>因为改用比较熟悉的tableView,所以对功能的实现比较方便快捷</p><h4 id="使用QStringList存储指定目录文件及文件夹"><a href="#使用QStringList存储指定目录文件及文件夹" class="headerlink" title="使用QStringList存储指定目录文件及文件夹"></a>使用QStringList存储指定目录文件及文件夹</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString desktop_path = QStandardPaths::<span class="built_in">writableLocation</span>(QStandardPaths::DesktopLocation);</span><br><span class="line">strList = <span class="built_in">getAllFiles</span>(desktop_path) + <span class="built_in">getAllFolds</span>(desktop_path);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取目录下的所有文件夹</span></span><br><span class="line"><span class="function">QStringList <span class="title">SearchEngine::getAllFolds</span><span class="params">(<span class="keyword">const</span> QString&amp; foldPath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QStringList folds;</span><br><span class="line">    <span class="function">QDirIterator <span class="title">it</span><span class="params">(foldPath, QDir::Dirs | QDir::NoDotAndDotDot, QDirIterator::Subdirectories)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (it.<span class="built_in">hasNext</span>())</span><br><span class="line">    {</span><br><span class="line">        it.<span class="built_in">next</span>();</span><br><span class="line">        QFileInfo fileInfo = it.<span class="built_in">fileInfo</span>();</span><br><span class="line">        folds &lt;&lt; fileInfo.<span class="built_in">absoluteFilePath</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> folds;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//获取目录下的所有文件</span></span><br><span class="line"><span class="function">QStringList <span class="title">SearchEngine::getAllFiles</span><span class="params">(<span class="keyword">const</span> QString&amp; foldPath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QStringList folds;</span><br><span class="line">    <span class="function">QDirIterator <span class="title">it</span><span class="params">(foldPath, QDir::Files | QDir::NoDotAndDotDot, QDirIterator::Subdirectories)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (it.<span class="built_in">hasNext</span>()) {</span><br><span class="line">        it.<span class="built_in">next</span>();</span><br><span class="line">        QFileInfo fileInfo = it.<span class="built_in">fileInfo</span>();</span><br><span class="line">        folds &lt;&lt; fileInfo.<span class="built_in">absoluteFilePath</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> folds;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="初始化数据库-通过双主键的设置不再对重复数据进行添加"><a href="#初始化数据库-通过双主键的设置不再对重复数据进行添加" class="headerlink" title="初始化数据库,通过双主键的设置不再对重复数据进行添加"></a>初始化数据库,通过双主键的设置不再对重复数据进行添加</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QString create_sql = <span class="string">"CREATE TABLE if not exists FileData(FileName VARCHAR (20),\</span></span><br><span class="line"><span class="string">        FilePath VARCHAR (100),\</span></span><br><span class="line"><span class="string">        FileSize INT (20),\</span></span><br><span class="line"><span class="string">        FileValue VARCHAR (20),\</span></span><br><span class="line"><span class="string">        PRIMARY KEY (FileName, FilePath))"</span>;<span class="comment">//通过双主键过滤重复文件加快遍历速度</span></span><br><span class="line"><span class="function">QSqlQuery <span class="title">query</span><span class="params">(db)</span></span>;<span class="comment">//执行sql语句</span></span><br><span class="line">query.<span class="built_in">exec</span>(create_sql);</span><br><span class="line">query.<span class="built_in">finish</span>();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="搜索栏输入关键字快速模糊搜索的初步实现"><a href="#搜索栏输入关键字快速模糊搜索的初步实现" class="headerlink" title="搜索栏输入关键字快速模糊搜索的初步实现"></a>搜索栏输入关键字快速模糊搜索的初步实现</h4><p>使用tableModel对sql封装实现的<code>setFilter</code>函数对数据库内的数据进行筛选显示</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchEngine::ShowResult</span><span class="params">(<span class="keyword">const</span> QString&amp; arg1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QString str = <span class="built_in">tr</span>(<span class="string">"FileName like '%1'"</span>).<span class="built_in">arg</span>(<span class="string">"%"</span> + arg1.<span class="built_in">left</span>(<span class="number">1</span>) + <span class="string">"%"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arg1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        str += <span class="built_in">tr</span>(<span class="string">" and FileName like '%1'"</span>).<span class="built_in">arg</span>(<span class="string">"%"</span> + arg1.<span class="built_in">mid</span>(i, <span class="number">1</span>) + <span class="string">"%"</span>);</span><br><span class="line">    }</span><br><span class="line">    tableModel-&gt;<span class="built_in">setFilter</span>(str);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="右键菜单-包含启动和删除功能"><a href="#右键菜单-包含启动和删除功能" class="headerlink" title="右键菜单,包含启动和删除功能"></a>右键菜单,包含启动和删除功能</h4><p><strong>.h文件:</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QMenu *tableviewMenu;               <span class="comment">//右键菜单</span></span><br><span class="line">    QAction *Action1;                   <span class="comment">//右键菜单项1</span></span><br><span class="line">    QAction *Action2;                   <span class="comment">//右键菜单项2</span></span><br></pre></td></tr></tbody></table></figure><p><strong>.cpp文件:</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置右键菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchEngine::InitRightClickMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    tableviewMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(ui-&gt;tableView);</span><br><span class="line">    Action1 = <span class="keyword">new</span> <span class="built_in">QAction</span>();</span><br><span class="line">    Action2 = <span class="keyword">new</span> <span class="built_in">QAction</span>();</span><br><span class="line">    Action1-&gt;<span class="built_in">setText</span>(<span class="string">"打开"</span>);</span><br><span class="line">    Action2-&gt;<span class="built_in">setText</span>(<span class="string">"删除"</span>);</span><br><span class="line">    tableviewMenu-&gt;<span class="built_in">addAction</span>(Action1);</span><br><span class="line">    tableviewMenu-&gt;<span class="built_in">addAction</span>(Action2);</span><br><span class="line">    <span class="built_in">connect</span>(Action1,&amp;QAction::triggered,<span class="keyword">this</span>,&amp;SearchEngine::Action1triggered);</span><br><span class="line">    <span class="built_in">connect</span>(Action2,&amp;QAction::triggered,<span class="keyword">this</span>,&amp;SearchEngine::Action2triggered);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>右键菜单要配合获取当前Index的槽函数使用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取鼠标当前index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchEngine::on_tableView_customContextMenuRequested</span><span class="params">(<span class="keyword">const</span> QPoint &amp;pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QModelIndex index = ui-&gt;tableView-&gt;<span class="built_in">indexAt</span>(pos);</span><br><span class="line">    <span class="keyword">if</span>(index.<span class="built_in">isValid</span>())</span><br><span class="line">    {</span><br><span class="line">        Action1-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        Action2-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        Action1-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">        Action2-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>-&gt;tableIndex = index;</span><br><span class="line">    tableviewMenu-&gt;<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());<span class="comment">//菜单出现位置为鼠标右键点击的位置</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2021-07-28"><a href="#2021-07-28" class="headerlink" title="2021/07/28"></a>2021/07/28</h2><h3 id="完成的功能"><a href="#完成的功能" class="headerlink" title="完成的功能"></a>完成的功能</h3><p>今日的工作完成了通过设置代理实现tableModel显示富文本的功能,在tableModel上给文件设置图标,程序启动后默认隐藏，通过 alt+空格 唤出，再次按下 alt+空格 隐藏的功能,优化了搜索算法</p><h3 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="通过代理显示富文本"><a href="#通过代理显示富文本" class="headerlink" title="通过代理显示富文本"></a>通过代理显示富文本</h4><p>参考了网上的资料,构造一个新的代理类继承QStyledItemDelegate,重写paint函数,最后在tableModel上设置此代理实现</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDelegate::paint</span><span class="params">(QPainter *painter, <span class="keyword">const</span> QStyleOptionViewItem &amp;option, <span class="keyword">const</span> QModelIndex &amp;index)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    QStyleOptionViewItem optionV4 = option;</span><br><span class="line">    <span class="built_in">initStyleOption</span>(&amp;optionV4, index);</span><br><span class="line"></span><br><span class="line">    QStyle *style = optionV4.widget? optionV4.widget-&gt;<span class="built_in">style</span>() : QApplication::<span class="built_in">style</span>();</span><br><span class="line"></span><br><span class="line">    QTextDocument doc;</span><br><span class="line">    doc.<span class="built_in">setHtml</span>(optionV4.text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Painting item without text</span></span><br><span class="line">    optionV4.text = <span class="built_in">QString</span>();</span><br><span class="line">    style-&gt;<span class="built_in">drawControl</span>(QStyle::CE_ItemViewItem, &amp;optionV4, painter);</span><br><span class="line"></span><br><span class="line">    QAbstractTextDocumentLayout::PaintContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Highlighting text if item is selected</span></span><br><span class="line">    <span class="keyword">if</span> (optionV4.state &amp; QStyle::State_Selected)</span><br><span class="line">        ctx.palette.<span class="built_in">setColor</span>(QPalette::Text, optionV4.palette.<span class="built_in">color</span>(QPalette::Active, QPalette::HighlightedText));</span><br><span class="line"></span><br><span class="line">    QRect textRect = style-&gt;<span class="built_in">subElementRect</span>(QStyle::SE_ItemViewItemText, &amp;optionV4);</span><br><span class="line">    painter-&gt;<span class="built_in">save</span>();</span><br><span class="line">    painter-&gt;<span class="built_in">translate</span>(textRect.<span class="built_in">topLeft</span>());</span><br><span class="line">    painter-&gt;<span class="built_in">setClipRect</span>(textRect.<span class="built_in">translated</span>(-textRect.<span class="built_in">topLeft</span>()));</span><br><span class="line">    doc.<span class="built_in">documentLayout</span>()-&gt;<span class="built_in">draw</span>(painter, ctx);</span><br><span class="line">    painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>将搜索的关键字改为富文本的形式</strong></p><p>函数中如果arg1(就是lineEdit里用户要搜索的内容)包含b或B,则先将每一条文件的文件名里的b更改为<code>&lt;b&gt;b&lt;b/&gt;</code>的形式,之后每次遇到b的时候就要自动跳过,不然在之后的替换会将<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>里的b给替换掉,造成混乱.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg1 != <span class="string">""</span>)    {        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tableModel-&gt;<span class="built_in">rowCount</span>(); i++)        {            <span class="keyword">bool</span> hasB = <span class="literal">false</span>;            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arg1.<span class="built_in">size</span>(); j++)            {                QString fileName = tableModel-&gt;<span class="built_in">data</span>(tableModel-&gt;<span class="built_in">index</span>(i, <span class="number">0</span>), Qt::DisplayRole).<span class="built_in">toString</span>();                <span class="keyword">if</span>(!hasB&amp;(arg1.<span class="built_in">contains</span>(<span class="string">'b'</span>)||arg1.<span class="built_in">contains</span>(<span class="string">'B'</span>)))                {                    fileName.<span class="built_in">replace</span>(<span class="string">'b'</span>, <span class="string">"&lt;b&gt;b&lt;/b&gt;"</span>, Qt::CaseInsensitive);                    tableModel-&gt;<span class="built_in">setData</span>(tableModel-&gt;<span class="built_in">index</span>(i, <span class="number">0</span>), fileName);                    hasB = <span class="literal">true</span>;                }                <span class="keyword">int</span> index = fileName.<span class="built_in">indexOf</span>(arg1[j], <span class="number">0</span>, Qt::CaseInsensitive);                <span class="keyword">if</span>(arg1[j]==<span class="string">'b'</span>)<span class="keyword">continue</span>;                fileName.<span class="built_in">replace</span>(arg1[j], <span class="string">"&lt;b&gt;"</span> + fileName.<span class="built_in">mid</span>(index, <span class="number">1</span>) + <span class="string">"&lt;/b&gt;"</span>, Qt::CaseInsensitive);                tableModel-&gt;<span class="built_in">setData</span>(tableModel-&gt;<span class="built_in">index</span>(i, <span class="number">0</span>), fileName);            }        }    }</span><br></pre></td></tr></tbody></table></figure><h4 id="给文件设置图标"><a href="#给文件设置图标" class="headerlink" title="给文件设置图标"></a>给文件设置图标</h4><p><strong>获取图标函数</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon <span class="title">GetFileIcon</span><span class="params">(QString path)</span><span class="keyword">const</span></span>{    <span class="function">QFileInfo <span class="title">fileInfo</span><span class="params">(path)</span></span>;    QFileIconProvider icon_provider;    QIcon icon = icon_provider.<span class="built_in">icon</span>(fileInfo);    <span class="keyword">return</span> icon;}</span><br></pre></td></tr></tbody></table></figure><p>尝试过改写代理:当<code>column==0</code>时<code>return Icon</code>的方法,但是图标出现的位置会覆盖在文字上面,达不到想要的效果</p><p>最后发现重写QSqlTableModel里的data以添加图标的方式可以行得通</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承原有的QSqlTableModel,加以改进class SqlTableModel : public QSqlTableModel{    Q_OBJECTpublic:    explicit SqlTableModel(QObject *parent=0);    QVariant data(const QModelIndex &amp;idx, int role)const;};//重写data以添加图标QVariant SqlTableModel::data(const QModelIndex&amp; index, int role)const{    QVariant value = QSqlTableModel::data(index, role);    if (index.column() == 0 &amp;&amp; Qt::DecorationRole == role)    {        QModelIndex inddex = index.siblingAtColumn(1);        return GetFileIcon(inddex.data().toString()+"\\"+index.data().toString());    }    return value;}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="隐藏到系统托盘"><a href="#隐藏到系统托盘" class="headerlink" title="隐藏到系统托盘"></a>隐藏到系统托盘</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐藏至系统托盘的实现void SearchEngine::InitSystemTray(){    SystemTrayMenu = new QMenu(this);    SystemTrayAction1 = new QAction(SystemTrayMenu);//新建两个按钮    SystemTrayAction2 = new QAction(SystemTrayMenu);    SystemTrayAction1-&gt;setText("Show Window");//设置文本    SystemTrayAction2-&gt;setText("Quit");    SystemTrayMenu-&gt;addAction(SystemTrayAction1);//菜单增加按钮    SystemTrayMenu-&gt;addAction(SystemTrayAction2);    m_systemTray-&gt;setIcon(QIcon(":/image/SearchIcon.png"));//设置图标    m_systemTray-&gt;setToolTip("SearchEngine");    connect(SystemTrayAction1, &amp;QAction::triggered, this,[=](){this-&gt;show();});    connect(SystemTrayAction2, &amp;QAction::triggered, this,[=](){this-&gt;close();});    connect(m_systemTray, &amp;QSystemTrayIcon::activated, this, &amp;SearchEngine::activeTray);//点击托盘，执行相应的动作    m_systemTray-&gt;show();}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>点击时的槽函数</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统托盘点击信号void SearchEngine::activeTray(QSystemTrayIcon::ActivationReason reason){    switch (reason)    {    case QSystemTrayIcon::Context://右键        SystemTrayMenu-&gt;exec(QCursor::pos());//菜单出现位置为鼠标右键点击的位置        break;    case QSystemTrayIcon::Trigger://单击        this-&gt;show();        break;    case QSystemTrayIcon::DoubleClick://双击        break;    case QSystemTrayIcon::MiddleClick://中键单击        break;    case QSystemTrayIcon::Unknown://未知类型        break;    }}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>重写closeEvent</strong></p><p>重写以拦截桌面窗口关闭的事件,执行隐藏的函数,而窗口close的函数则忽略</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchEngine::closeEvent</span><span class="params">(QCloseEvent *event)</span></span>{    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">isVisible</span>())    {        <span class="built_in">hide</span>(); <span class="comment">//隐藏窗口        event-&gt;ignore(); //忽略事件    }}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Alt-Space热键"><a href="#Alt-Space热键" class="headerlink" title="Alt+Space热键"></a>Alt+Space热键</h4><p>一开始的思路是用键盘事件的监控,搭配信号和槽进行组合快捷键的实现,不过只能在界面可见的时候进行监控,当隐藏时不能实现窗口的呼出.通过查询阅读学习多方资料:CSDN博客园等博客网站,阅读GitHub上大佬实现的QHotKey源码,之后改用重写QApplication类的方法,发现会出现别的难以解决的问题.尝试了多种方法.最后确定使用并实现了利用windows系统的注册热键函数实现并进行提取封装成一个热键注册类和一个windows事件筛选类.</p><p><strong>热键类主要函数</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册热键bool  MyGlobalShortCut::registerHotKey(){    shortcuts.insert(qMakePair(VK_SPACE, MOD_ALT),this);    return RegisterHotKey(0, MOD_ALT ^ VK_SPACE, MOD_ALT, VK_SPACE);}//注销热键bool  MyGlobalShortCut::unregisterHotKey(){    return UnregisterHotKey(0, (quint32)MOD_ALT ^ VK_SPACE);}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>热键类的析构及构造函数</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造时注册热键并安装筛选器MyGlobalShortCut::MyGlobalShortCut(){    m_filter = new MyWinEventFilter(this);    m_app-&gt;installNativeEventFilter(m_filter);    registerHotKey();}//析构时注销热键MyGlobalShortCut::~MyGlobalShortCut(){    unregisterHotKey();}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>筛选器函数</strong></p><p>屏蔽掉其他的windows热键,不然Alt加空格时会在左上角弹出一个菜单</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyWinEventFilter::nativeEventFilter</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;eventType, <span class="keyword">void</span> *message, qintptr *result)</span></span>{   <span class="keyword">if</span>(eventType == <span class="string">"windows_generic_MSG"</span>)    {        MSG *msg = <span class="keyword">static_cast</span>&lt;MSG *&gt;(message);        <span class="keyword">if</span>(msg-&gt;message == WM_HOTKEY)        {            <span class="keyword">const</span> quint32 keycode = <span class="built_in">HIWORD</span>(msg-&gt;lParam);            <span class="keyword">const</span> quint32 modifiers = <span class="built_in">LOWORD</span>(msg-&gt;lParam);            <span class="keyword">bool</span> res = m_shortcut-&gt;shortcuts.<span class="built_in">value</span>(<span class="built_in">qMakePair</span>(keycode, modifiers));            <span class="keyword">if</span>(res)            {                m_shortcut -&gt;<span class="built_in">activateShortcut</span>();                <span class="keyword">return</span> <span class="literal">true</span>;            }        }    }    <span class="keyword">return</span> <span class="literal">false</span>;}</span><br></pre></td></tr></tbody></table></figure><p>最后在<strong>main</strong>函数里加上,并将<code>w.show()</code>改为<code>w.hide()</code>以实现打开程序时隐藏至托盘的效果</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyGlobalShortCut *shortcut = <span class="keyword">new</span> <span class="built_in">MyGlobalShortCut</span>();    <span class="comment">//连接ALT+space信号槽    QObject::connect(shortcut,SIGNAL(activated()),&amp;w,SLOT(ALT_and_SPACEReceived()));    w.hide();</span></span><br></pre></td></tr></tbody></table></figure><p><strong>槽函数</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ALT+Space呼出或隐藏窗口void SearchEngine::ALT_and_SPACEReceived(){    if(this-&gt;isMinimized())//如果是最小化窗口时就会显示    {        this-&gt;showNormal();    }    else if(this-&gt;isVisible())//如果是显示中的窗口时就会隐藏    {        this-&gt;hide();    }    else//如果是隐藏中的窗口时就会显示    {        this-&gt;show();    }}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2021-07-29"><a href="#2021-07-29" class="headerlink" title="2021/07/29"></a>2021/07/29</h2><h3 id="完成的功能-1"><a href="#完成的功能-1" class="headerlink" title="完成的功能"></a>完成的功能</h3><p>今日的完成了中文名称的程序支持通过拼音首字母进行搜索的功能,增加了文件监控的功能,优化了筛选排序算法</p><h3 id="实现过程-2"><a href="#实现过程-2" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="通过拼音的首字母进行搜索"><a href="#通过拼音的首字母进行搜索" class="headerlink" title="通过拼音的首字母进行搜索"></a>通过拼音的首字母进行搜索</h4><p>通过网上查找信息,取得了别人写好的穷举法字库首字母表</p><p>将该功能提取成一个拼音转首字母类,并改进符合我们的搜索功能需要的转换函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">PinyinInitials::ToChineseSpell</span><span class="params">(QString strText)</span></span>{    <span class="keyword">if</span> (strText.<span class="built_in">length</span>() == <span class="number">0</span>)        <span class="keyword">return</span> strText;    QString myStr;    <span class="keyword">int</span> index = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strText.<span class="built_in">length</span>(); i++)    {        <span class="comment">// 若是字母或数字则直接输出        ushort vChar = strText[i].unicode();        if ((vChar &gt;= 32 &amp;&amp; vChar &lt;= 126))            myStr.append(strText[i]);        else        {            myStr.append(strText[i]);            index = (int)vChar - 19968;            if (index &gt;= 0 &amp;&amp; index &lt; strChineseFirstPY.length())                myStr.append(strChineseFirstPY[index]);        }    }    return myStr;}</span></span><br></pre></td></tr></tbody></table></figure><p>该函数的功能就是将<strong>包含中文字符的字符串</strong>转换成<strong>中文之后添加对应的大写英文字母的字符串</strong></p><p>我们将转换好的字符串存入FileValue中,之后搜索的时候搜索FileValue即可达到搜索中英文都可以显示出想要的数据的结果</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="built_in">tr</span>(<span class="string">"FileValue like '%1'"</span>).<span class="built_in">arg</span>(<span class="string">"%"</span> + arg1.<span class="built_in">left</span>(<span class="number">1</span>) + <span class="string">"%"</span>);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arg1.<span class="built_in">size</span>(); i++){    str += <span class="built_in">tr</span>(<span class="string">" and FileValue like '%1'"</span>).<span class="built_in">arg</span>(<span class="string">"%"</span> + arg1.<span class="built_in">mid</span>(i, <span class="number">1</span>) + <span class="string">"%"</span>);}tableModel-&gt;<span class="built_in">setFilter</span>(str);</span><br></pre></td></tr></tbody></table></figure><h4 id="文件监控的实现"><a href="#文件监控的实现" class="headerlink" title="文件监控的实现"></a>文件监控的实现</h4><p><strong>初始化</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件监管者的初始化void SearchEngine::InitFileSystemWatcher(){    QDir dir(desktop_path);    myWatcher.addPath(desktop_path);    myWatcher.addPaths(getAllFolds(desktop_path));  //监控文件夹    myWatcher.addPaths(getAllFiles(desktop_path));  //监控文件    dir.setFilter(QDir::NoDotAndDotDot | QDir::AllEntries);//排除.和..目录    connect(&amp;myWatcher, SIGNAL(directoryChanged(QString)), this, SLOT(onDirectoryChanged(QString)));    connect(&amp;myWatcher, SIGNAL(fileChanged(QString)), this, SLOT(onFileChanged(QString)));}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>文件变化信号槽</strong></p><p>目录变化时函数差不多只是将<code>getAllFiles()</code>更改为<code>getAllFolds()</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件变化时的槽函数,对数据库进行更改void SearchEngine::onFileChanged(QString str){    QStringList strList2 = getAllFiles(desktop_path);    QFileInfo info(str);    if(strList2.contains(str))//如果包含有则为新建文件,则增加数据库对应的数据    {        PinyinInitials py(info.fileName());        InsertData("FileData", info.fileName(), info.absolutePath(), info.size(), py.GetResult());    }    else//若不包含有则为删除文件,则删除数据库对应的数据    {        deleteData("FileData", "FilePath", info.absolutePath());    }    tableModel-&gt;select();}</span></span><br></pre></td></tr></tbody></table></figure><p>有需要可以添加这个MessageBox,不过程序本身数据库更新时它也会弹出消息,有点烦</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::QMessageBox::information(this, "文件更新", info.absolutePath()+"/"+info.fileName(), QMessageBox::Yes);</span><br></pre></td></tr></tbody></table></figure><p>有两种解决方法,一个是调用<code>myWatcher的removePath()</code>函数移除数据库,另一个是不添加MessageBox</p><h4 id="优化筛选排序算法-只实现了算法-没能加以应用"><a href="#优化筛选排序算法-只实现了算法-没能加以应用" class="headerlink" title="优化筛选排序算法(只实现了算法,没能加以应用)"></a>优化筛选排序算法(只实现了算法,没能加以应用)</h4><p>通过网上查询资料和学习,学习了<strong>编辑距离</strong>的有关知识,并且自己参考资料实现了一个计算莱文斯坦距离的算法,可以用计算出的相似度来进行排序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:    <span class="keyword">int</span> min_dist;<span class="comment">//相当于全局变量,可以响应每次递归的时候最小编辑距离的更新,当递归完时返回此结果    QString a;    QString b;    int n=a.size();    int m=b.size();void LevenshteinDistance::lwstBT(int i, int j, int edist) {    if (i == n || j == m)     {        if (i &lt; n)  edist += (n - i);     // a比b长，直接加上后续多余长度        if (j &lt; m)  edist += (m - j);     // 同上        if (edist &lt; min_dist) min_dist = edist; // 更新编辑距离取小值        return;    }    if (a[i] == b[j])// 当两个字符匹配    {                         lwstBT(i + 1, j + 1, edist);// 同时到下一个字符的对比    }    else  // 当两个字符不匹配,有三种方法:    {                                    lwstBT(i + 1, j, edist + 1);        // 删除a[i]或者b[j]前添加一个字符,编辑距离加1        lwstBT(i, j + 1, edist + 1);        // 删除b[j]或者a[i]前添加一个字符,编辑距离加1        lwstBT(i + 1, j + 1, edist + 1);    // 将a[i]和b[j]替换为相同字符    }}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>未实现的原因</strong></p><p>用tableModel的setdata方法设置的优先级数据,这个数据不能用tableModel或者tableView里的排序函数进行排序,因为tableModel或tableView里的排序函数是对数据库里的源数据进行排序,setdata的方法是对内存缓存进行更改.</p><p>只有把优先级真正写入数据库才能用我的优先级进行排序,但是每次输入一个字符就要重新对数据库里所有的数据进行更改并进行查询,这样频繁的写入数据库,反而降低了搜索速度,甚至程序会停止运行.</p><p>不过通过对导师的咨询得到了启发想到了一个方法:</p><p>​    如果可以重写tableView里的排序函数,并同时进行优先级的修改,那么原本先写再排的时间复杂度可以降低.应该有两条路可以走:一个是通过设置代理来更改model的存储方法,另一个是用重写data的方法来获得每条数据对应的优先级,然后再重写函数.</p><p>不过因为时间条件的不允许,算法的问题暂且放下.</p><h2 id="2021-07-30"><a href="#2021-07-30" class="headerlink" title="2021/07/30"></a>2021/07/30</h2><h3 id="完成的功能-2"><a href="#完成的功能-2" class="headerlink" title="完成的功能"></a>完成的功能</h3><p>今日的完成了qss的部分和程序外观的设计,以及未实现的排序算法的稍稍改进</p><h3 id="实现过程-3"><a href="#实现过程-3" class="headerlink" title="实现过程"></a>实现过程</h3><p>通过隐藏标题栏以及对鼠标事件的重写实现自定义的标题栏,使其可以进行拖动,最小化,最大化,窗口化,关闭的功能</p><h4 id="简单的优化筛选算法"><a href="#简单的优化筛选算法" class="headerlink" title="简单的优化筛选算法"></a>简单的优化筛选算法</h4><p>通过setQuery来进行sql语句的调用,再原有的基础上加上一个对字符串长度的排序,可以<strong>类似实现分级显示</strong>的效果</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableModel-&gt;<span class="built_in">select</span>();QString str = <span class="built_in">tr</span>(<span class="string">"FileValue like '%1'"</span>).<span class="built_in">arg</span>(<span class="string">"%"</span> + arg1.<span class="built_in">left</span>(<span class="number">1</span>) + <span class="string">"%"</span>);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arg1.<span class="built_in">size</span>(); i++){str += <span class="built_in">tr</span>(<span class="string">" and FileValue like '%1'"</span>).<span class="built_in">arg</span>(<span class="string">"%"</span> + arg1.<span class="built_in">mid</span>(i, <span class="number">1</span>) + <span class="string">"%"</span>);}QSqlQuery *query = <span class="keyword">new</span> <span class="built_in">QSqlQuery</span>(<span class="built_in">tr</span>(<span class="string">"SELECT * FROM FileData WHERE %1 ORDER BY LENGTH(FileName) ASC;"</span>).<span class="built_in">arg</span>(str));tableModel-&gt;<span class="built_in">setQuery</span>(*query);<span class="keyword">delete</span> query;</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是setQuery()函数在tablemodel中是<strong>保护类型</strong>的函数,因此需要去到qt源文件中进行对protected到public的更改,才可以使用.</p><h4 id="设置图标"><a href="#设置图标" class="headerlink" title="设置图标"></a>设置图标</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QImage *img=<span class="keyword">new</span> QImage;img-&gt;<span class="built_in">load</span>(<span class="string">":/image/SearchIcon.png"</span>);ui-&gt;SearchIcon-&gt;<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(*img));ui-&gt;SearchIcon-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);ui-&gt;SearchIcon-&gt;<span class="built_in">resize</span>(<span class="number">20</span>,<span class="number">20</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="读取QSS"><a href="#读取QSS" class="headerlink" title="读取QSS"></a>读取QSS</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">":/SearchEngine.qss"</span>)</span></span>;file.<span class="built_in">open</span>(QFile::ReadOnly);QString styleSheet = <span class="built_in">QLatin1String</span>(file.<span class="built_in">readAll</span>());QMainWindow::<span class="built_in">setStyleSheet</span>(styleSheet);file.<span class="built_in">close</span>();</span><br></pre></td></tr></tbody></table></figure><h4 id="对标题栏重写"><a href="#对标题栏重写" class="headerlink" title="对标题栏重写"></a>对标题栏重写</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对鼠标按压事件的判断,进行对窗口的移动void SearchEngine::mousePressEvent(QMouseEvent* event){    if(event-&gt;button() ==  Qt::LeftButton)    {        mousePoint = event-&gt;globalPos() - this-&gt;pos();        IsWindowMoveable = true;    }}//窗口随着鼠标移动而移动void SearchEngine::mouseMoveEvent(QMouseEvent*event){    if(IsWindowMoveable)    {        move(event-&gt;globalPos() - mousePoint);    }}//鼠标松开窗口不可移动void SearchEngine::mouseReleaseEvent(QMouseEvent* event){    IsWindowMoveable = false;}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>重写paint事件以绘制窗口阴影</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchEngine::paintEvent</span><span class="params">(QPaintEvent *event)</span></span>{    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;    <span class="keyword">int</span> SHADOW_WIDTH = <span class="number">4</span>;    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="literal">true</span>);    painter.<span class="built_in">fillRect</span>(<span class="built_in">QRect</span>(SHADOW_WIDTH, SHADOW_WIDTH, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - <span class="number">2</span> * SHADOW_WIDTH, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() - <span class="number">2</span> * SHADOW_WIDTH), <span class="built_in">QBrush</span>(Qt::white));    <span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">231</span>,<span class="number">234</span>,<span class="number">237</span>,<span class="number">40</span>)</span></span>;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SHADOW_WIDTH; i++)    {        color.<span class="built_in">setAlpha</span>(<span class="number">120</span> - <span class="built_in">qSqrt</span>(i) * <span class="number">40</span>);        painter.<span class="built_in">setPen</span>(color);        painter.<span class="built_in">drawRoundedRect</span>(SHADOW_WIDTH - i, SHADOW_WIDTH - i, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - (SHADOW_WIDTH - i) * <span class="number">2</span>, <span class="keyword">this</span>-&gt;<span class="built_in">height</span>() - (SHADOW_WIDTH - i) * <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>);    }}</span><br></pre></td></tr></tbody></table></figure><p><strong>窗口最大化和窗口化的同一个按钮</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放大窗口void SearchEngine::on_pushButton_2_clicked(bool checked){    QList&lt;QScreen *&gt; list_screen =  QGuiApplication::screens();  //多显示器    QRect rect = list_screen.at(0)-&gt;geometry();    if(checked)//最大化    {        this-&gt;showMaximized();        ui-&gt;tableView-&gt;setColumnWidth(0, rect.width()/5-20);        ui-&gt;tableView-&gt;setColumnWidth(1, rect.width()/5*3-20);        ui-&gt;tableView-&gt;setColumnWidth(2, rect.width()/5-20);        ui-&gt;pushButton_2-&gt;setStyleSheet(                    "#pushButton_2{"                        "image: url(:/image/showMaximized.png);}"                    "#pushButton_2:hover{"                        "image: url(:/image/showMaximized_hover.png);}");    }    else//窗口化    {        this-&gt;showNormal();        ui-&gt;tableView-&gt;setColumnWidth(0, 240);        ui-&gt;tableView-&gt;setColumnWidth(1, 410);        ui-&gt;tableView-&gt;setColumnWidth(2, 100);        ui-&gt;pushButton_2-&gt;setStyleSheet(                    "#pushButton_2{"                        "image: url(:/image/showWindow.png);}"                    "#pushButton_2:hover{"                        "image: url(:/image/showWindow_hover.png);}");    }}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="2021-07-31"><a href="#2021-07-31" class="headerlink" title="2021/07/31"></a>2021/07/31</h2><h3 id="完成的功能-3"><a href="#完成的功能-3" class="headerlink" title="完成的功能"></a>完成的功能</h3><ol><li>在SearchEngine的构造函数里,加上一个加载对话框,可以显示初始化写入数据库的进度,当全部的初始化工作完成时,自动退出(替代多线程);</li><li>文档的编写</li><li>打包程序提交.</li></ol><h3 id="实现过程-4"><a href="#实现过程-4" class="headerlink" title="实现过程"></a>实现过程</h3><p>最开始初始化数据库的部分是想用多线程来实现,在实现的过程中发现采用多线程初始化数据库会阻塞QT的事件循环,程序框会直接变成未响应,暂时也不知道怎么处理,由于时间原因,临时创建一个有ProgressBar的模态对话框,来显示写入数据库的进度.不过第一次打开exe程序时还是比较慢.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld = <span class="keyword">new</span> LoadingDialog;    ld-&gt;<span class="built_in">setProgressbarRange</span>(<span class="number">0</span>,strList.<span class="built_in">size</span>());    ld-&gt;<span class="built_in">show</span>();                 <span class="comment">//运行加载窗口    setQtStyleSheet();          //设置QSS    InitDatabase();             //每次打开软件会遍历一遍文件,实现文件监控    InitSystemTray();           //初始化系统托盘    InittableViewModel();       //初始化TableModel    InitRightClickMenu();       //初始化右键菜单    InitFileSystemWatcher();    //打开软件后会对所有子目录进行文件监控    ld-&gt;close();                //初始化完成时退出加载窗口</span></span><br></pre></td></tr></tbody></table></figure><h4 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h4><p>后台加载数据库.</p><h4 id="文档的编写"><a href="#文档的编写" class="headerlink" title="文档的编写"></a>文档的编写</h4><p>以上.</p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP基础</title>
      <link href="2021/07/19/CPP%E5%9F%BA%E7%A1%80/"/>
      <url>2021/07/19/CPP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class 类名</span><br><span class="line">{</span><br><span class="line">    private:</span><br><span class="line">        私有的数据和成员函数;</span><br><span class="line">    public:</span><br><span class="line">        公用的数据和成员函数;</span><br><span class="line">    protected:</span><br><span class="line">        保护的数据和成员函数;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>探讨<code>public/private</code>给我们带来了什么好处？</p><ol><li>类的内部数据得到保护</li><li>类的使用方法更加明确，不易出错</li><li>类的实现细节更容易修改</li><li>内部数据修改有了统一入口，更容易调试</li></ol><h4 id="默认生成的函数"><a href="#默认生成的函数" class="headerlink" title="默认生成的函数"></a>默认生成的函数</h4><ul><li>默认构造函数</li><li>默认析构函数</li><li>拷贝构造函数</li><li>赋值操作符</li><li>地址运算符</li></ul><h4 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h4><ul><li>类声明<ul><li>类名（类型 形参，类型 形参，…）</li></ul></li><li>定义对象<ul><li>类名 对象（实参，实参，…）</li></ul></li><li>特殊的成员函数<ul><li>对象创建时自动执行，无需用户调用且不能被调用（其实可以）</li><li>与类名同名</li><li>可传入参数，无返回值</li><li>可重载</li><li>如果用户不定义，则编译器自动生成一个<h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_name(int v1,const int&amp; v2):var(v1),var2(v2)</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classname (const classname &amp;obj) {</span><br><span class="line">   // 构造函数的主体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以下两种方式会调用拷贝构造函数:</p><ol><li>classname A(B);</li><li>classnaem A=B;<h4 id="析构函数（Destructor）"><a href="#析构函数（Destructor）" class="headerlink" title="析构函数（Destructor）"></a>析构函数（Destructor）</h4></li></ol><ul><li>声明<ul><li>~类名（）</li></ul></li><li>特殊的成员函数<ul><li>对象生命周期即将结束时自动被调用，释放资源或是执行清理工作</li><li>类名前加一个“~“</li><li>没有返回值，也没有函数参数</li><li>可以显示调用析构函数（慎用）</li></ul></li><li>Can destructors be virtual in C++<h4 id="构造和析构函数链"><a href="#构造和析构函数链" class="headerlink" title="构造和析构函数链"></a>构造和析构函数链</h4></li><li>构造函数链<ul><li>构造类实例会沿着继承链调用所有的基类ctor</li><li>调用顺序: base first, derive next</li></ul></li><li>析构函数链<ul><li>dtor与ctor正好相反</li><li>调用顺序: derive first, base next</li></ul></li></ul><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><ul><li>指向对象自身首地址</li><li>引用整个对象<code>*this</code></li><li>仅能在类内部使用</li></ul><h4 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h4><ul><li>修饰类成员<ul><li>成员函数</li><li>成员变量</li></ul></li><li>调用方式<ul><li>类名::静态成员名</li></ul></li><li>特殊性<ul><li>this指针无效</li><li>不能访问类成员</li></ul></li></ul><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><ul><li>不可修改对象</li><li>声明<ul><li>数据类型 函数名 （参数列表）const；</li></ul></li><li>只要成员函数不修改对象就应声明为const<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *getData() const;</span><br></pre></td></tr></tbody></table></figure>函数的功能很简单，仅仅是为了获取成员变量的值，没有任何修改成员变量的企图，所以加了 const 限制，这是一种保险的做法，同时也使得语义更加明显。<h4 id="inheritance→get-basic"><a href="#inheritance→get-basic" class="headerlink" title="inheritance→get_basic()"></a>inheritance→get_basic()</h4></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superior</span> :</span><span class="keyword">public</span> basic{</span><br><span class="line"><span class="function">basic* <span class="title">get_basic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">- }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul><li>不受权限控制，访问私有成员</li><li>三种友元<ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul></li><li>注意<ul><li>友员也破环了类的隐藏与封装</li><li>友元关系不能被继承</li><li>友元关系是单向的，不具有交换性</li><li>友元关系不具有传递性</li></ul></li></ul><h2 id="面向对象编程思想"><a href="#面向对象编程思想" class="headerlink" title="面向对象编程思想"></a>面向对象编程思想</h2><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>面向对象的程序设计的思路和人们日常生活中处理问题的思路是相似的。在自然世界和社会生活中，一个复杂的事物总是由许多部分组成的。任何一个事物都可以看成一个对象（object）。对象可大可小，是构成系统的基本单位。  </p><h4 id="对象的两个要素"><a href="#对象的两个要素" class="headerlink" title="对象的两个要素"></a>对象的两个要素</h4><p>任何一个对象都应当具有这两个要素，即属性（attribute）和行为（behavior），它能根据外界给的信息进行相应的操作。一个对象往往是由一组属性和一组行为构成的。一般来说，凡是具备属性和行为这两种要素的，都可以作为对象。</p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽象是对具体的对象（问题）进行概括，提取出一类对象的公共属性/行为。</p><ul><li>数据抽象：描述某类对象的属性或状态</li><li>函数抽象：描述某类对象的共有的行为特征或具有的功能</li></ul><p>抽象的结果：形成类的定义</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>在抽象出的数据成员、函数成员基础上提取出对外接口，定义访问权限。以达到简化外部使用的目的。使用者不必了解具体的实现细节，而只需要通过外部接口，来访问类的成员。</p><h2 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h2><ul><li>封装（Encapsulation)<ul><li>将数据和方法（数据上的操作）捆绑，定义新的类型</li><li>接口与实现分离，隐藏实现细节</li></ul></li><li>继承（Inherit）<ul><li>子类对基类进行特化（扩展、覆盖、重定义）</li><li>达到复用代码的目的</li></ul></li><li>多态（Polymorphism）<ul><li>允许不同类的对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式</li></ul></li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul><li>is-a一般是泛化关系<ul><li>继承：表示类与类之间的继承关系</li><li>实现：表示一个类实现接口的功能</li></ul></li><li>use-a为依赖关系<ul><li>表示两个相互独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务</li></ul></li><li>has-a一般是聚合关系<ul><li>两个对象有不同的生命周期</li></ul></li><li>contain-a为组合关系<ul><li>体现了严格的部分与整体的关系，生命周期相同</li></ul></li></ul><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>#define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：<code>#define macro-name replacement-text </code></p><p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef π  // 先测试π是否被宏定义过</span><br><span class="line">#define π 3.1415926 //如果没有则定义并执行程序段1</span><br><span class="line">//程序段1   </span><br><span class="line">#else       //如果已经定义则执行程序段2</span><br><span class="line">//程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure><h4 id="参数宏"><a href="#参数宏" class="headerlink" title="参数宏"></a>参数宏</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MIN(a,b) (a&lt;b ? a : b)</span><br></pre></td></tr></tbody></table></figure><h4 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h4><blockquote><p>#运算符会把replacement-text令牌转换为用引号引起来的字符串。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MYSTR( x ) #x</span><br><span class="line">···</span><br><span class="line">cout &lt;&lt; MYSTR(HELLO C++) &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：<code>HELLO C++</code></p><p>预处理器把<code>cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;</code></p><p>转换成了<code>cout &lt;&lt; "HELLO C++" &lt;&lt; endl;</code></p><blockquote><p>##运算符用于连接两个令牌。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define concat(a, b) a ## b</span><br><span class="line">···</span><br><span class="line">int xy = 100;</span><br><span class="line">cout &lt;&lt; concat(x, y);</span><br></pre></td></tr></tbody></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：<code>100</code></p><p>预处理器把<code>cout &lt;&lt; concat(x, y);</code></p><p>转换成了<code>cout &lt;&lt; xy;</code></p><h4 id="C-中的预定义宏"><a href="#C-中的预定义宏" class="headerlink" title="C++ 中的预定义宏"></a>C++ 中的预定义宏</h4><div style="width:80px">宏</div> | 描述|:---:|---||```__LINE__``` |代表当前源代码中的行号的整数常量。||```__FILE__``` |这会在程序编译时包含当前文件名。||```__DATE__``` |进行预处理的日期，格式为"Mmm dd yyyy"||```__TIME__``` | 源文件编译时间，格式为"hh：mm：ss"||```__FUNCTION__ ``` | 当前所在函数名|<h2 id="C-和-C-的兼容及差异"><a href="#C-和-C-的兼容及差异" class="headerlink" title="C 和 C++的兼容及差异"></a>C 和 C++的兼容及差异</h2><h4 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h4><ul><li>只读<ul><li>初始化后不可改变(必须初始化)</li></ul></li><li>语法<ul><li>const int var;</li><li>int const var;</li><li>修饰指针时const位置不同语义不同<ul><li>const int* p;//指针可修改，指向对象不可修改</li><li>int const* p;//指针不可修改，指向内容可修改</li></ul></li></ul></li><li>与C的差异<ul><li>与#define的区别</li><li>C也有，略有差异<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4></li></ul></li><li>C语言形式:(类型)(表达式):(int)var</li><li>C++新增形式:类型名(表达式):int(var)<h4 id="内存申请"><a href="#内存申请" class="headerlink" title="内存申请"></a>内存申请</h4><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">高地址</td><td align="center">栈区(向下增长)↓</td></tr><tr><td align="center">↑</td><td align="center">堆区(向上增长)↑</td></tr><tr><td align="center">↑</td><td align="center">静态区(全局区)</td></tr><tr><td align="center">↑</td><td align="center">常量区</td></tr><tr><td align="center">低地址</td><td align="center">代码区</td></tr></tbody></table><h4 id="堆内存申请-释放"><a href="#堆内存申请-释放" class="headerlink" title="堆内存申请/释放"></a>堆内存申请/释放</h4>C语言: malloc / free</li></ul><p>C++: new / delete</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;; i++)</span><br><span class="line">{</span><br><span class="line">char* block = new char[1024 * 1024];</span><br><span class="line">cout &lt;&lt; "已申请" &lt;&lt; i + 1 &lt;&lt; "M内存" &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>变量别名</li><li>函数参数传递方式<ul><li>值传递</li><li>地址传递</li><li>引用传递<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void passParamByValue(std::string param)</span><br><span class="line">{</span><br><span class="line">param = "changed param";</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void passParamByRef(std::string&amp; param)</span><br><span class="line">{</span><br><span class="line">param = "changed param";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>注意事项<ul><li>必须初始化</li><li>初始化后不能引用另一个对象</li></ul></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li>语法<ul><li>inline void func();</li></ul></li><li>原理<ul><li>在编译时将所调用函数的代码直接嵌入到主调函数中，减少函数调用开销</li></ul></li><li>提示<ul><li>应仅用来修饰简单函数<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2></li></ul></li><li>函数起名字存在痛点</li><li>函数名相同，参数类型/个数不同</li><li>注意事项<ul><li>不支持以返回值区分函数</li><li>支持const修饰区分<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2></li></ul></li><li>语法<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T max(T a, T b)</span><br><span class="line">{</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2></li><li>语法<ul><li><code>void func(int param1, float param2 = 0.0f);</code></li></ul></li><li>注意事项<ul><li>默认值一般在声明中指定</li><li>若给某一参数设置了默认值，那么其后所有参数都必须也设置默认值</li><li>若给已经设置默认值的参数传递实际值，则该参数左边的所有参数，无论是否有默认值，都必须传递实际参数</li></ul></li></ul><h2 id="作用域与命名空间"><a href="#作用域与命名空间" class="headerlink" title="作用域与命名空间"></a>作用域与命名空间</h2><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>作用域（scope）描述了一个名字在文件（编译单元）的多大范围内可见</li><li>解决名字冲突的痛点</li><li>局部域是包含在函数定义或者块（如括号包含的）中的程序文本部分</li><li>每个类定义都引入了一个独立的类域</li><li>用户主动添加的具有名字的最外层作用域<h4 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h4></li><li>可以是类，也可以是名字空间</li><li>但不能是局部的<ul><li>lambda函数</li></ul></li></ul><h4 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h4><ul><li>声明 （可嵌套可不连续）<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace MySpace</span><br><span class="line">{</span><br><span class="line">    ... ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>使用<ul><li>提前声明：</li><li>using 名称::变量</li><li>using 名称::函数名</li></ul></li><li>直接使用：<ul><li>名称::变量或函数名</li></ul></li></ul><h2 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h2><ul><li>链接性（linkage）描述了名称如何在各个单元中的共享<ul><li>外部链接</li><li>内部链接</li></ul></li><li>默认为外部链接</li><li>修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”</li><li>extern声明不是定义，即不分配存储空间。</li><li>static修饰后改为内部链接</li></ul><h2 id="输出流格式控制"><a href="#输出流格式控制" class="headerlink" title="输出流格式控制"></a>输出流格式控制</h2><p>C++ 中常用的输出流操纵算子如表所示，它们都是在头文件 iomanip 中定义的；要使用这些流操纵算子，必须包含该头文件。</p><blockquote><p>注意：“流操纵算子”一栏中的星号*不是算子的一部分，星号表示在没有使用任何算子的情况下，就等效于使用了该算子</p></blockquote><table><thead><tr><th align="left"><div style="width:100px">流操纵算子</div></th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">==常用==</td><td align="left"></td></tr><tr><td align="left">*dec</td><td align="left">以十进制形式输出整数</td></tr><tr><td align="left">hex</td><td align="left">以十六进制形式输出整数</td></tr><tr><td align="left">oct</td><td align="left">以八进制形式输出整数</td></tr><tr><td align="left">fixed</td><td align="left">以普通小数形式输出浮点数</td></tr><tr><td align="left">scientific</td><td align="left">以科学计数法形式输出浮点数</td></tr><tr><td align="left">left</td><td align="left">左对齐，即在宽度不足时将填充字符添加到右边</td></tr><tr><td align="left">*right</td><td align="left">右对齐，即在宽度不足时将填充字符添加到左边</td></tr><tr><td align="left">setbase(b)</td><td align="left">设置输出整数时的进制，b=8、10 或 16</td></tr><tr><td align="left">setw(w)</td><td align="left">指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td></tr><tr><td align="left">setfill(c)</td><td align="left">在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td></tr><tr><td align="left">setprecision(n)</td><td align="left">设置输出浮点数的精度为n。  在使用非fixed且非scientific方式输出的情况下，n即为有效数字最多的位数，如果有效数字位数超过n，则小数部分四舍五入，或自动变为科学计数法输出并保留一共n位有效数字。在使用 fixed 方式和 scientific 方式输出的情况下，n是小数点后面应保留的位数</td></tr><tr><td align="left">setiosflags(flag)</td><td align="left">将某个输出格式标志置为 1</td></tr><tr><td align="left">resetiosflags(flag)</td><td align="left">将某个输出格式标志置为 0</td></tr><tr><td align="left">==不常用==</td><td align="left"></td></tr><tr><td align="left">boolapha</td><td align="left">把 true 和 false 输出为字符串</td></tr><tr><td align="left">*noboolalpha</td><td align="left">把 true 和 false 输出为 0、1</td></tr><tr><td align="left">showbase</td><td align="left">输出表示数值的进制的前缀</td></tr><tr><td align="left">*noshowbase</td><td align="left">不输出表示数值的进制.的前缀</td></tr><tr><td align="left">showpoint</td><td align="left">总是输出小数点</td></tr><tr><td align="left">*noshowpoint</td><td align="left">只有当小数部分存在时才显示小数点</td></tr><tr><td align="left">showpos</td><td align="left">在非负数值中显示 +</td></tr><tr><td align="left">*noshowpos</td><td align="left">在非负数值中不显示 +</td></tr><tr><td align="left">*skipws</td><td align="left">输入时跳过空白字符</td></tr><tr><td align="left">noskipws</td><td align="left">输入时不跳过空白字符</td></tr><tr><td align="left">uppercase</td><td align="left">十六进制数中使用A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td></tr><tr><td align="left">*nouppercase</td><td align="left">十六进制数中使用</td></tr><tr><td align="left">internal</td><td align="left">数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td></tr></tbody></table><h3 id="科学计数法表示"><a href="#科学计数法表示" class="headerlink" title="科学计数法表示"></a>科学计数法表示</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; scientific &lt;&lt; π &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><h3 id="保留有效数字"><a href="#保留有效数字" class="headerlink" title="保留有效数字"></a>保留有效数字</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout.precision(3);//保留几位就填几</span><br><span class="line"></span><br><span class="line">//位数不足时</span><br><span class="line">cout.precision(10);</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; 3.1415926;//不足十位</span><br></pre></td></tr></tbody></table></figure><h3 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iomanip&gt;  //不要忘了头文件</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2);//保留几位就填几</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line"></span><br><span class="line">printf("%.2lf", π);//不会影响之后输出</span><br></pre></td></tr></tbody></table></figure><h2 id="C-编程范式"><a href="#C-编程范式" class="headerlink" title="C++ 编程范式"></a>C++ 编程范式</h2><ul><li>融合多种编程范式</li><li>以面向对象编程+泛型编程为主</li><li>支持函数式编程</li></ul><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><ul><li>目的<ul><li>实现C++的STL（Standard Template Library 标准模板库）</li></ul></li><li>支持机制<ul><li>模板（Templates）的实质就是参数化类型，简而言之：把特定的类型信息抽象化，抽象成模板参数T。这样就可以编写出任意类型动作一致的类或方法，在使用时才指定实际类型</li></ul></li><li>特性<ul><li>泛型一定程度上杜绝了类型转换</li></ul></li></ul><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><ul><li>面向过程编程(c)</li><li><h4 id="面向对象编程-c"><a href="#面向对象编程-c" class="headerlink" title="面向对象编程(c++)"></a>面向对象编程(c++)</h4><ul><li>重用性<blockquote><p>代码可复用，维护成本低</p></blockquote></li><li>灵活性<blockquote><p>基于可复用的模块进行重新组装、重构，以达到实现不同的功能</p></blockquote></li><li>扩展性<blockquote><p>对新增需求友好，模块可扩展</p></blockquote></li></ul></li><li>函数式编程(js)</li><li>泛型编程</li></ul><h2 id="使用编译器通常的流程"><a href="#使用编译器通常的流程" class="headerlink" title="使用编译器通常的流程"></a>使用编译器通常的流程</h2><blockquote><p>.cpp→编译→.obj→链接→.exe</p></blockquote><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote><p>F5 运行</p></blockquote><blockquote><p>F10 单步运行</p></blockquote><blockquote><p>F11 单步运行会进入到函数内</p></blockquote><ul><li>断点<ul><li>普通断点</li><li>数据断点</li><li>断点条件</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="2021/07/19/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/07/19/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><ul><li>编译器自动完成</li><li>转换场景<ul><li>初始化</li><li>变量赋值</li><li>计算表达式</li></ul></li><li>转换规则<ul><li>尽量类型向上升级</li><li>尽量避免数据丢失</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line"></span><br><span class="line">A(bool) --&gt;B(char)</span><br><span class="line">B(char) --&gt;C(short int)</span><br><span class="line">C(short int) --&gt;D(int)</span><br><span class="line">D(int) --&gt;E(unsigned int)</span><br><span class="line">E(unsigned int) --&gt;F(long)</span><br><span class="line">F(long) --&gt;G(unsigned)</span><br><span class="line">G(unsigned) --&gt;H(long long)</span><br><span class="line">H(long long) --&gt;I(float)</span><br><span class="line">I(float) --&gt;J(double)</span><br><span class="line">J(double) --&gt; K(long double) </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><h4 id="C风格类型转换"><a href="#C风格类型转换" class="headerlink" title="C风格类型转换"></a>C风格类型转换</h4><p><code>float f = (float)3 / 4;</code></p><figure class="highlight plaintext"><figcaption><span>f </span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 语义较多，能力太强</span><br><span class="line">- 容易误用，不推荐</span><br><span class="line">## 更安全的类型转换</span><br><span class="line">#### 静态类型转换</span><br><span class="line">- 基本数据类型间转换</span><br><span class="line">- 基类及子类间转换</span><br><span class="line">- 编译时进行类型检查</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>static_cast&lt;目标类型&gt;(源类型)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">源类型和目标类型只要有一个方向可以隐式转换，那么两个方向都可以做静态类型转换，如果不能则报错</span><br><span class="line">#### 动态类型转换</span><br><span class="line">- 向下转换</span><br><span class="line">    - 基类指针转换为子类指针</span><br><span class="line">    - 主要用于多态场景</span><br><span class="line">- 运行时类型检查</span><br><span class="line">    - 基类指针不指向子类对象时转为空指针</span><br><span class="line">    - 底层实现基于虚表指针，无虚函数类不能使用dynamic_cast</span><br><span class="line">- static_cast</span><br><span class="line">    - 也可以做向下转换</span><br><span class="line">    - 不具备运行时类型检查</span><br><span class="line">    - 存在风险</span><br><span class="line">- 也可用于引用，和指针用法类似</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>dynamic_cast&lt;目标类型&gt;(源类型)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将基类类型参数转换为派生类类型，源类型和目标类型必须同是引用或指针，且目标类型和源类型之间存在继承关系，否则报错</span><br><span class="line"></span><br><span class="line">#### 去常类型转换</span><br><span class="line">- const指针或引用转为非const</span><br><span class="line">- 存在非法场景（未定义行为）</span><br><span class="line">- 使用场景较少</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>const_cast&lt;目标类型&gt;(源类型)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源类型和目标类型必须同是引用或指针，且目标类型和源类型之间只有常属性的区别，否则报错</span><br></pre></td></tr></tbody></table></figure><pre><code>int* p1 = NULL;const int* p2 = NULL;//const不是基本的数据类型p1 = const_cast&lt;int*&gt;(p2);p2 = const_cast&lt;const int*&gt;(p1);//用来加const和去const</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#### 重解释类型转换</span><br><span class="line">- 不同类型指针之间、指针与整型间强转</span><br><span class="line">- 编译器不对指向对象的类型做任何检查</span><br><span class="line">- 谨慎使用</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>reinterpret_cast&lt;目标类型&gt;(源类型)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源类型和目标类型必须同是指针，或者一个指针一个整数，否则报错</span><br></pre></td></tr></tbody></table></figure><pre><code>int* p = NULL;char* p2 = NULL;p = reinterpret_cast&lt;int*&gt;(p2);p2 = reinterpret_cast&lt;int*&gt;(p);int c = 0;c = reinterpret_cast&lt;int&gt;(p2);</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## 类型转换函数</span><br><span class="line">- 类可以提供自定义的类型转换函数</span><br><span class="line">- 类似操作符重载</span><br><span class="line">- 可以用explicit修饰，避免隐式转换</span><br><span class="line">- 一般使用const修饰</span><br><span class="line"></span><br><span class="line">## Upcasting and Downcasting (向上/向下转型)</span><br><span class="line"></span><br><span class="line">- upcasting : Assigning a pointer of a derived class type to a pointer of its base  class type (将派生类类型指针赋值给基类类型指针)</span><br><span class="line"></span><br><span class="line">- downcasting : Assigning a pointer of a base class type to a pointer of its  derived class type. (将基类类型指针赋值给派生类类型指针)</span><br><span class="line"></span><br><span class="line">上转可不适用dynamic_cast而隐式转换</span><br></pre></td></tr></tbody></table></figure><p>GeometricObject *g = new Circle(1);<br>Circle *c = new Circle(2);<br>g = c; //Correct</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下转必须显式执行</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><p>c = dynamic_cast&lt;Circle *&gt;(g);</p><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数</title>
      <link href="2021/07/19/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>2021/07/19/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="虚函数表-Virtual-Table"><a href="#虚函数表-Virtual-Table" class="headerlink" title="虚函数表 Virtual Table"></a><a href="https://cloud.tencent.com/developer/article/1599283">虚函数表</a> Virtual Table</h2><p>对于一个类来说，<strong>如果类中存在虚函数，那么该类的大小就会多4个字节，然而这4个字节就是一个指针的大小，这个指针指向虚函数表。</strong> 所以，如果对象存在虚函数，那么编译器就会生成一个指向虚函数表的指针，所有的虚函数都存在于这个表中，<strong>虚函数表就可以理解为一个数组，每个单元用来存放虚函数的地址。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base {</span><br><span class="line">public:</span><br><span class="line">virtual void a() { cout &lt;&lt; "Base a()" &lt;&lt; endl; }</span><br><span class="line">virtual void b() { cout &lt;&lt; "Base b()" &lt;&lt; endl; }</span><br><span class="line">virtual void c() { cout &lt;&lt; "Base c()" &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class Derive : public Base {</span><br><span class="line">public:</span><br><span class="line">virtual void b() { cout &lt;&lt; "Derive b()" &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "----------Base-------------" &lt;&lt; endl;</span><br><span class="line">Base* q = new Base;</span><br><span class="line">long* tmp1 = (long*)q;</span><br><span class="line">long* vptr1 = (long*)(*tmp1);</span><br><span class="line">for (int i = 0; i &lt; 3; i++) {</span><br><span class="line">printf("vptr[%d] : %p\n", i, vptr1[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Derive* p = new Derive;</span><br><span class="line">long* tmp = (long*)p;</span><br><span class="line">long* vptr = (long*)(*tmp);</span><br><span class="line">cout &lt;&lt; "---------Derive------------" &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) {</span><br><span class="line">printf("vptr[%d] : %p\n", i, vptr[i]);</span><br><span class="line">}</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h2><p>如果基类并不需要回收清理什么，那么析构函数就可以是虚构函数</p><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><ul><li><p>一般的建议是作为基类的析构函数是虚函数</p></li><li><p>当指针指向的对象是基类类型时，delete销毁对象的时候并不会调用派生类的析构函数，这样就造成了对象销毁不完整</p><blockquote><p> 总结一下虚析构函数的作用：</p></blockquote></li></ul><blockquote><p>（1）如果基类的析构函数不加virtual关键字<br>当基类的析构函数不声明成虚析构函数的时候，当派生类继承父类，基类的指针指向派生类时，delete掉基类的指针，只调动基类的析构函数，而不调动派生类的析构函数。</p></blockquote><blockquote><p>（2）如果基类的析构函数加virtual关键字<br>当基类的析构函数声明成虚析构函数的时候，当派生类继承基类，基类的指针指向派生类时，delete掉基类的指针，先调动派生类的析构函数，再调动基类的析构函数。</p></blockquote><blockquote><p>原理分析</p></blockquote><p>由于基类的析构函数为虚函数，所以派生类会在所有属性的前面形成虚表，而虚表内部存储的就是基类的虚函数。<br>当delete基类的指针时，由于派生类的析构函数与基类的析构函数构成多态，所以得先调动派生类的析构函数；之所以再调动基类的析构函数，是因为delete的机制所引起的,delete 基类指针所指的空间，要调用基类的析构函数。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><ul><li><p>是指一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class typename :virtual public inheritance{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">Function</span><span class="params">(Argument List)</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2></li><li><p>含有纯虚函数的类就是抽象类</p></li><li><p>抽象类没有完整的信息，只能是派生类的基类</p></li><li><p>抽象类不能有实例，不能有静态成员</p></li><li><p>派生类应该实现抽象类的所有方法</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="2021/07/19/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>2021/07/19/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>一般格式如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型说明符&gt; operator &lt;运算符符号&gt; (&lt;参数表&gt;)</span><br><span class="line">{</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不可重载：<br>|    Operator    |                  |      |<br>| :————: | —————- | —- |<br>|    <code>.</code>     | 类属关系运算符   |      |<br>|    <code>.*</code>    | 成员指针运算符   |      |<br>|    <code>::</code>    | 作用域运算符     |      |<br>|    <code>#</code>     | 编译预处理符号   |      |<br>|    <code>?:</code>    | 三目条件运算符   |      |<br>| <code>sizeof()</code> | 取数据类型的长度 |      |</p><ul><li>重载运算符限制在c++语言中已有的运算符范围内的允许重载的运算符之中，<strong>不能创建新的运算符</strong></li><li>运算符重载的实质是函数重载，遵循函数重载的选择原则</li><li>重载之后<strong>不能改变运算符的优先级和结合性</strong>，也不能够改变运算符操作数的个数及语法结构</li><li>运算符重载不能改变该运算符用于内部类型对象的含义</li><li>运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，<strong>重载的功能应当与原有功能相类似</strong></li><li>重载运算符的函数不能有默认的参数，否则就改变了运算符的参数个数</li><li>重载的运算符只能是用户自定义类型</li></ul><table><thead><tr><th align="center"><div style="width:60px">表达式</div></th><th>作为成员函数</th><th>作为非成员函数</th><th>示例</th></tr></thead><tbody><tr><td align="center">@a</td><td><code>(a).operator@ ()</code></td><td>operator@ (a)</td><td><code>   !std::cin</code>调用<code> std::cin.operator!()</code></td></tr><tr><td align="center">a@b</td><td><code>(a).operator@ (b)</code></td><td>operator@ (a, b)</td><td><code>   std::cout &lt;&lt; 42</code>调用<code> std::cout.operator&lt;&lt;(42)</code></td></tr><tr><td align="center">a=b</td><td><code>(a).operator= (b)</code></td><td>不能是非成员</td><td><code>   std::string s; s = "abc";</code>调用<code> s.operator=("abc")</code></td></tr><tr><td align="center">a(b…)</td><td><code>(a).operator()(b...)</code></td><td>不能是非成员</td><td><code>   std::random_device r; auto n = r();</code>调用<code> r.operator()()</code></td></tr><tr><td align="center">a[b]</td><td><code>(a).operator[](b)</code></td><td>不能是非成员</td><td><code>   std::map&lt;int, int&gt; m; m[1] = 2;</code>调用<code> m.operator[](1)</code></td></tr><tr><td align="center">a-&gt;</td><td><code>(a).operator-&gt;()</code></td><td>不能是非成员</td><td><code>   auto p = std::make_unique&lt;S&gt;(); p-&gt;bar()</code>调用<code> p.operator-&gt;()</code></td></tr><tr><td align="center">a@</td><td><code>(a).operator@ (0)</code></td><td>operator@ (a, 0)</td><td><code>   std::vector&lt;int&gt;::iterator i = v.begin(); i++</code>调用<code> i.operator++(0)</code></td></tr></tbody></table><p>此表中，@ 是表示所有匹配运算符的占位符：@a 为所有前缀运算符，a@ 为除 -&gt; 以外的所有后缀运算符，a@b 为除 = 以外的所有其他运算符</p><h2 id="类型转换重载"><a href="#类型转换重载" class="headerlink" title="类型转换重载"></a>类型转换重载</h2><p>double类型转换重载</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator double();</span><br></pre></td></tr></tbody></table></figure><p>bool类型转换重载</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator bool();</span><br></pre></td></tr></tbody></table></figure><h2 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h2><p>语法格式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 类名</span><br><span class="line">{</span><br><span class="line">    返回类型 operator 运算符 (参数表);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="友元运算符重载"><a href="#友元运算符重载" class="headerlink" title="友元运算符重载"></a>友元运算符重载</h2><p>在类的内部，定义友元运算符重载函数的格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class xx</span><br><span class="line">{</span><br><span class="line">    friend &lt;返回类型说明符&gt; operator &lt;运算符符号&gt; (形参表)</span><br><span class="line">    {</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h4 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="- 一元运算符重载"></a>- 一元运算符重载</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec2D operator -()</span><br><span class="line">{</span><br><span class="line">return Vec2D(-x, -y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int&amp; operator[](int i)</span><br><span class="line">{</span><br><span class="line">if (i &gt; SIZE)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "索引超过最大值" &lt;&lt; endl;</span><br><span class="line">// 返回第一个元素</span><br><span class="line">return arr[0];</span><br><span class="line">}</span><br><span class="line">return arr[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="和-–-运算符重载"><a href="#和-–-运算符重载" class="headerlink" title="++ 和 – 运算符重载"></a>++ 和 – 运算符重载</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//重载前缀递增运算符++</span><br><span class="line">Time operator ++()</span><br><span class="line">{</span><br><span class="line">second++;</span><br><span class="line">if (second &gt; 59)</span><br><span class="line">{</span><br><span class="line">second -= 60;</span><br><span class="line">minute++;</span><br><span class="line">}</span><br><span class="line">if (minute &gt; 59)</span><br><span class="line">{</span><br><span class="line">minute -= 60;</span><br><span class="line">hour++;</span><br><span class="line">}</span><br><span class="line">if (hour &gt; 23)</span><br><span class="line">{</span><br><span class="line">hour -= 24;</span><br><span class="line">}</span><br><span class="line">return *this;</span><br><span class="line">}</span><br><span class="line">//重载后缀递增运算符++</span><br><span class="line">Time operator ++(int)</span><br><span class="line">{</span><br><span class="line">Time T = *this;</span><br><span class="line">second++;</span><br><span class="line">if (second &gt; 59)</span><br><span class="line">{</span><br><span class="line">second -= 60;</span><br><span class="line">minute++;</span><br><span class="line">}</span><br><span class="line">if (minute &gt; 59)</span><br><span class="line">{</span><br><span class="line">minute -= 60;</span><br><span class="line">hour++;</span><br><span class="line">}</span><br><span class="line">if (hour &gt; 23)</span><br><span class="line">{</span><br><span class="line">hour -= 24;</span><br><span class="line">}</span><br><span class="line">return T;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="输入输出运算符重载"><a href="#输入输出运算符重载" class="headerlink" title="输入输出运算符重载"></a>输入输出运算符重载</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp; output,const Time&amp; T)</span><br><span class="line">{</span><br><span class="line">output &lt;&lt; T.hour &lt;&lt;":"&lt;&lt; T.minute &lt;&lt; ":" &lt;&lt; T.second;</span><br><span class="line">return output;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">friend istream&amp; operator&gt;&gt;(istream&amp; input, Time&amp;T)</span><br><span class="line">{</span><br><span class="line">input &gt;&gt; T.hour &gt;&gt; T.minute &gt;&gt; T.second;</span><br><span class="line">return input;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void operator=(const Time&amp; T)</span><br><span class="line">{</span><br><span class="line">hour = T.hour;</span><br><span class="line">minute = T.minute;</span><br><span class="line">second = T.second;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="覆盖-override-与重载-overload"><a href="#覆盖-override-与重载-overload" class="headerlink" title="覆盖(override)与重载(overload)"></a>覆盖(override)与重载(overload)</h2><ul><li><p><strong>成员函数覆盖</strong>是指派生类重新定义基类的虚函数</p></li><li><p><strong>成员函数重载</strong>是指函数名相同，参数不同（数量、类型、次序）</p></li><li><p><strong>成员函数隐藏</strong>（重定义）</p></li></ul><ol><li>不在同一个作用域内（分别位于基类与继承类中）</li><li>函数名字相同</li><li>返回值可以不同</li><li>参数不同。此时，无论有无<code>virtual</code>关键字，基类的函数将被隐藏</li><li>参数相同，但是基类函数没有<code>virtual</code>关键字。此时，基类的函数被隐藏</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一个具有两道作业的批处理系统</title>
      <link href="2021/06/17/%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E4%B8%A4%E9%81%93%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/06/17/%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E4%B8%A4%E9%81%93%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>有一个具有2道作业的批处理系统，作业调度采用短作业优先的调度算法，进程调度采用以优先数为基础的抢占式调度算法。在下表所示的作业序列，作业优先数即为进程优先数，优先数越小优先级越高。</p><table><thead><tr><th align="center">作业名</th><th align="center">到达时间</th><th align="center">估计运行时间</th><th align="center">优先数</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">10:00</td><td align="center">40分</td><td align="center">5</td></tr><tr><td align="center">B</td><td align="center">10:20</td><td align="center">30分</td><td align="center">3</td></tr><tr><td align="center">C</td><td align="center">10:30</td><td align="center">50分</td><td align="center">4</td></tr><tr><td align="center">D</td><td align="center">10:50</td><td align="center">20分</td><td align="center">6</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 列出所有作业进入内存时间及结束时间</span><br><span class="line">(2) 计算平均周转时间。</span><br><span class="line">【提示】在本题中，每个作业的运行将经历2级调度：作业调度和进程调度。作业调度采用短作业优先调度算法，进程调度采用基于优先数的抢占式调度算法，高优先级的进程可以抢占系统处理机。只有当作业调度程序将作业装入内存后，方能参与进程调度。本题中的批处理系统是2道作业系统，因此每次只能有2道作业进入系统内存。</span><br></pre></td></tr></tbody></table></figure><ol><li><p>10：00，A作业到达，进入系统 开始运行。</p></li><li><p>10：20，B作业到达，系统内存中只有一道作业A，B作业进入内存，此时A运行20min，还剩20min,由于B作业的优先数小，即优先级高，则作业A进入就绪状态，作业B开始运行。</p></li><li><p>10：30，C作业到达，内存中已有两道作业，则在后备队列中等待被作业调度程序调度，A等待10min,剩20min,继续等待，B运行10min,还剩20min,继续运行。</p></li><li><p>10：50， D作业到达，B作业完成，内存中只剩下作业A,剩20min，作业D与作业C相比，作业D的运行所需时间少被调到进内存，内存中的A和D相比，A的优先级高，A继续运行。</p></li><li><p>11：10，作业A运行完成，作业C被调度进内存，内存中有作业D和作业C，C的优先级比D高，C先运行。</p></li><li><p>12：00 ，作业C完成，D运行。</p></li><li><p>12：20，作业D完成。</p></li></ol><p>周转时间 = 作业完成时间 - 作业到达时间<br>平均周转时间：(70+30+90+90)/4=70</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘访问调度算法</title>
      <link href="2021/06/17/%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>2021/06/17/%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>假定一个磁盘有200个柱面，编号为0一199，在完成了磁道125外的请求后，当前正在磁道143处为一个请求服务。若请求队列的先后顺序为86，147，91，177，94，1 50，102，175，130；试问：为了完成上述请求，下列算法存取臂所以移动的总量是多少？并计算存取臂移动的顺序。（1）FCFS（先来先服务）；（2）SSTF（最短寻道时间优先）；（3）SCAN（扫描）算法；（4）电梯调度算法。</p><h4 id="（1）FCFS（先来先服务）算法"><a href="#（1）FCFS（先来先服务）算法" class="headerlink" title="（1）FCFS（先来先服务）算法"></a>（1）FCFS（先来先服务）算法</h4><p>磁头移动顺序为：143→86→147→91→177→94→150→102→175→130，</p><p>磁头移动总量是：（143-86）+（147-86）+（147-91）+（177-91）+（177-94）+（150-94）+（150-102）+（175-102）+（175-130）=565（柱面）</p><h4 id="（2）SSTF（最短寻道时间优先）算法"><a href="#（2）SSTF（最短寻道时间优先）算法" class="headerlink" title="（2）SSTF（最短寻道时间优先）算法"></a>（2）SSTF（最短寻道时间优先）算法</h4><p>磁头移动顺序为：143→147→150→130→102→94→91→86→175→177，</p><p>磁头移动总量是：（147-143）+（150-147）+（150-130）+（130-102）+（102-94）+（94-91）+（91-86）+（175-86）+（177-175）=162（柱面）</p><h4 id="（3）SCAN（扫描）算法"><a href="#（3）SCAN（扫描）算法" class="headerlink" title="（3）SCAN（扫描）算法"></a>（3）SCAN（扫描）算法</h4><p>磁头移动顺序为：143→147→150→175→177→199→130→102→94→91→86→0，</p><p>磁头移动总量是：（199-143）+200=256（柱面）</p><h4 id="（4）电梯调度算法。"><a href="#（4）电梯调度算法。" class="headerlink" title="（4）电梯调度算法。"></a>（4）电梯调度算法。</h4><p>磁头移动顺序为：143→147→150→175→177→130→102→94→91→86，<br>磁头移动总量是：（177-143）+（177-86）=125（柱面）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面置换算法</title>
      <link href="2021/06/01/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>2021/06/01/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define 块 3</span><br><span class="line">#define 页 20</span><br><span class="line"></span><br><span class="line">//查找是否有空闲内存</span><br><span class="line">int findSpace(int block[])</span><br><span class="line">{</span><br><span class="line">for (int i = 0; i &lt; 3; i++)</span><br><span class="line">{</span><br><span class="line">if (block[i] == -1)//大于-1表示此块有页面i</span><br><span class="line">return i;//返回空白物理块的物理块号</span><br><span class="line">}</span><br><span class="line">return -1;//-1,此块为空</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int findExist(int block[], int p)</span><br><span class="line">{</span><br><span class="line">for (int i = 0; i &lt; 3; i++)</span><br><span class="line">{</span><br><span class="line">if (block[i] == p)</span><br><span class="line">return i;//返回页面所在的物理块号</span><br><span class="line">}</span><br><span class="line">return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void display(int Temp[3][20], char lack[], int Lcount, int Rcount, int page[])</span><br><span class="line">{</span><br><span class="line">double rate;</span><br><span class="line">cout &lt;&lt; "访问序列 ";</span><br><span class="line">for (int n = 0; n &lt; 20; n++)</span><br><span class="line">{</span><br><span class="line">printf("%2d", page[n]);</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for (int m = 0; m &lt; 3; m++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "物理块[" &lt;&lt; m &lt;&lt; "]";</span><br><span class="line">for (int n = 0; n &lt; 20; n++)</span><br><span class="line">{</span><br><span class="line">printf("%2d", Temp[m][n]);</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; "         ";</span><br><span class="line">for (int k = 0; k &lt; 20; k++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; " " &lt;&lt; lack[k];</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; "缺页中断的次数是: " &lt;&lt; Lcount &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "页面置换的次数是: " &lt;&lt; Rcount &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">rate = (double)Lcount / 20;</span><br><span class="line">cout &lt;&lt; "缺页率为: " &lt;&lt; rate &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">//最佳置换算法(最长时间未访问)</span><br><span class="line">void OPT(int page[], int block[])</span><br><span class="line">{</span><br><span class="line">int Lcount = 0;</span><br><span class="line">int Rcount = 0;</span><br><span class="line">int access[3];</span><br><span class="line">int max = 0;</span><br><span class="line">int Temp[3][20] = { 0 };</span><br><span class="line">char lack[20] = { '\0' };</span><br><span class="line">int E, S;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 20; i++)</span><br><span class="line">{</span><br><span class="line">E = findExist(block, page[i]);</span><br><span class="line">S = findSpace(block);</span><br><span class="line"></span><br><span class="line">if (E != -1)  //内存中存在该页面</span><br><span class="line">{</span><br><span class="line">for (int k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = ' ';</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">else if (S != -1)  //内存中有空白物理块</span><br><span class="line">{</span><br><span class="line">block[S] = page[i];</span><br><span class="line">for (int k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">for (int n = 0; n &lt; 3; n++)</span><br><span class="line">{</span><br><span class="line">access[n] = 0;</span><br><span class="line">}</span><br><span class="line">for (int k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">for (int m = i; m &lt; 20; m++)</span><br><span class="line">{</span><br><span class="line">if (block[k] != page[m])</span><br><span class="line">access[k]++;</span><br><span class="line">else</span><br><span class="line">break;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">for (int k = 1; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">if (access[max] &lt; access[k])</span><br><span class="line">max = k;</span><br><span class="line">}</span><br><span class="line">block[max] = page[i];</span><br><span class="line">max = 0;</span><br><span class="line">for (int k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">Rcount++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "-----------------------OPT-----------------------" &lt;&lt; endl;</span><br><span class="line">display(Temp, lack, Lcount, Rcount, page);</span><br><span class="line">}</span><br><span class="line">//先进先出置换算法</span><br><span class="line">void FIFO(int page[], int block[])</span><br><span class="line">{</span><br><span class="line">int Lcount = 0; //缺页次数</span><br><span class="line">int Rcount = 0; //置换次数</span><br><span class="line">int Temp[3][20] = { 0 };</span><br><span class="line">char lack[20] = { '\0' };</span><br><span class="line">int E;</span><br><span class="line">int S;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 20; i++)</span><br><span class="line">{</span><br><span class="line">E = findExist(block, page[i]);</span><br><span class="line">S = findSpace(block);</span><br><span class="line">if (E != -1)   //内存中存在该页面</span><br><span class="line">{</span><br><span class="line">for (int k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = ' ';</span><br><span class="line">}</span><br><span class="line">else if (S != -1)     //有空白块</span><br><span class="line">{</span><br><span class="line">for (int m = S; m &gt; 0; m--)</span><br><span class="line">{</span><br><span class="line">block[m] = block[m - 1];</span><br><span class="line">}</span><br><span class="line">block[0] = page[i];</span><br><span class="line">for (int k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">}</span><br><span class="line">else//页面置换</span><br><span class="line">{</span><br><span class="line">for (int m = 3 - 1; m &gt; 0; m--)</span><br><span class="line">{</span><br><span class="line">block[m] = block[m - 1];</span><br><span class="line">}</span><br><span class="line">block[0] = page[i];</span><br><span class="line">for (int k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">Rcount++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "-----------------------FIFO----------------------" &lt;&lt; endl;</span><br><span class="line">display(Temp, lack, Lcount, Rcount, page);</span><br><span class="line">}</span><br><span class="line">//最近最久未使用置换算法</span><br><span class="line">void LRU(int page[], int block[])</span><br><span class="line">{</span><br><span class="line">int m, k, i;</span><br><span class="line">int R[3] = { 0 };</span><br><span class="line">int Lcount = 0; /*缺页次数*/</span><br><span class="line">int Rcount = 0; /*置换次数*/</span><br><span class="line">int Temp[3][20] = { 0 };</span><br><span class="line">char lack[20] = { '\0' };</span><br><span class="line">int E;</span><br><span class="line">int S;</span><br><span class="line">for (i = 0; i &lt; 20; i++)</span><br><span class="line">{</span><br><span class="line">E = findExist(block, page[i]);</span><br><span class="line">S = findSpace(block);</span><br><span class="line">if (E != -1)//内存中存在该页面</span><br><span class="line">{</span><br><span class="line">R[E] = 0;</span><br><span class="line">for (k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">if (k == E)</span><br><span class="line">continue;</span><br><span class="line">R[k]++;</span><br><span class="line">}</span><br><span class="line">for (k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = ' ';</span><br><span class="line">}</span><br><span class="line">else if (S != -1)//有空白块</span><br><span class="line">{</span><br><span class="line">R[S] = 0;</span><br><span class="line">block[S] = page[i];</span><br><span class="line">for (k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">}</span><br><span class="line">else//页面置换</span><br><span class="line">{</span><br><span class="line">int Rmax = 0;</span><br><span class="line">int count = 0;</span><br><span class="line">for (m = 0; m &lt; 3; m++)</span><br><span class="line">{</span><br><span class="line">if (Rmax &lt;= R[m])</span><br><span class="line">{</span><br><span class="line">Rmax = R[m];</span><br><span class="line">count = m;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">block[count] = page[i];</span><br><span class="line">R[count] = 0;</span><br><span class="line">for (k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">if (k == count)</span><br><span class="line">continue;</span><br><span class="line">R[k]++;</span><br><span class="line">}</span><br><span class="line">for (k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">Rcount++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "-----------------------LRU-----------------------" &lt;&lt; endl;</span><br><span class="line">display(Temp, lack, Lcount, Rcount, page);</span><br><span class="line">}</span><br><span class="line">//Clock置换算法(NRU)</span><br><span class="line">void ClOCK(int page[], int block[])</span><br><span class="line">{</span><br><span class="line">int m, k, i, n = 0;</span><br><span class="line">int Lcount = 0; /*缺页次数*/</span><br><span class="line">int Rcount = 0; /*置换次数*/</span><br><span class="line">int Temp[3][20] = { 0 };</span><br><span class="line">char lack[20] = { '\0' };</span><br><span class="line">int access[3];</span><br><span class="line">int E;</span><br><span class="line">int S;</span><br><span class="line">for (k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">access[k] = 0;</span><br><span class="line">}</span><br><span class="line">for (i = 0; i &lt; 20; i++)</span><br><span class="line">{</span><br><span class="line">E = findExist(block, page[i]);</span><br><span class="line">S = findSpace(block);</span><br><span class="line">if (E != -1)   /*内存中存在该页面*/</span><br><span class="line">{</span><br><span class="line">access[E] = 1;</span><br><span class="line">n = (E + 1) % 3;</span><br><span class="line">for (k = 0; k &lt; 3; k++)   /*保存物理块此时的状态*/</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = ' ';</span><br><span class="line">}</span><br><span class="line">else if (S != -1)   /*有空白块*/</span><br><span class="line">{</span><br><span class="line">block[S] = page[i];</span><br><span class="line">access[S] = 1;</span><br><span class="line">for (k = 0; k &lt; 3; k++)</span><br><span class="line">{</span><br><span class="line">Temp[k][i] = block[k];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">}</span><br><span class="line">else     /*页面置换*/</span><br><span class="line">{</span><br><span class="line">while (1)</span><br><span class="line">{</span><br><span class="line">if (access[n] == 0)</span><br><span class="line">{</span><br><span class="line">block[n] = page[i];</span><br><span class="line">access[n] = 1;</span><br><span class="line">for (m = 0; m &lt; 3; m++)</span><br><span class="line">{</span><br><span class="line">Temp[m][i] = block[m];</span><br><span class="line">}</span><br><span class="line">lack[i] = '%';</span><br><span class="line">Lcount++;</span><br><span class="line">Rcount++;</span><br><span class="line">n++;</span><br><span class="line">n = n % 3;</span><br><span class="line">break;</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">access[n] = 0;</span><br><span class="line">n++;</span><br><span class="line">n = n % 3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "----------------------CLOCK----------------------" &lt;&lt; endl;</span><br><span class="line">display(Temp, lack, Lcount, Rcount, page);</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">int page[20];</span><br><span class="line">int block[3];</span><br><span class="line">for (int i = 0; i &lt; 3; i++)</span><br><span class="line">{</span><br><span class="line">block[i] = -1;</span><br><span class="line">}</span><br><span class="line">srand((unsigned)time(NULL));</span><br><span class="line">for (int i = 0; i &lt; 20; i++)</span><br><span class="line">{</span><br><span class="line">page[i] = rand() % 10;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">OPT (page, block);</span><br><span class="line">FIFO(page, block);</span><br><span class="line">LRU (page, block);</span><br><span class="line">ClOCK(page, block);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Swing + 图片转字符画</title>
      <link href="2021/06/01/%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/"/>
      <url>2021/06/01/%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scuec.computerschool.javaproject3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Image;</span><br><span class="line"><span class="keyword">import</span> java.awt.Toolkit;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.ImageIcon;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextArea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoveCard</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>{</span><br><span class="line">JFrame jf=<span class="keyword">new</span> JFrame(<span class="string">"LoveCard"</span>);    <span class="comment">//创建一个JFrame对象</span></span><br><span class="line">JPanel jp=<span class="keyword">new</span> JPanel();    <span class="comment">//创建一个JPanel对象</span></span><br><span class="line">JTextArea jt=<span class="keyword">new</span> JTextArea();</span><br><span class="line"><span class="keyword">private</span> JLabel timeLabel;</span><br><span class="line"><span class="keyword">private</span> JLabel timedisplay;</span><br><span class="line"><span class="keyword">private</span> String DEFAULT_TIME_FORMAT = <span class="string">"HH:mm:ss"</span>;<span class="comment">//设置时间格式</span></span><br><span class="line"><span class="keyword">private</span> String time;</span><br><span class="line"><span class="comment">//动态显示时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configTimeArea</span><span class="params">()</span> </span>{</span><br><span class="line">Timer tmr = <span class="keyword">new</span> Timer();</span><br><span class="line">tmr.scheduleAtFixedRate(<span class="keyword">new</span> JLabelTimerTask(),<span class="keyword">new</span> Date(), <span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">JLabelTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>{</span><br><span class="line">SimpleDateFormat dateFormatter = <span class="keyword">new</span> SimpleDateFormat(DEFAULT_TIME_FORMAT);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">time = dateFormatter.format(Calendar.getInstance().getTime());</span><br><span class="line">timedisplay.setText(time);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//图片转字符画</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawPic</span><span class="params">()</span> </span>{</span><br><span class="line">String picPath = <span class="string">"D:\\1583853509270.jpg"</span>;<span class="comment">//建议换一张分辨率小的</span></span><br><span class="line">BufferedImage img;</span><br><span class="line"><span class="comment">//String base = "-'.^,:;+=)?!ITLO8EM#%&amp;@";</span></span><br><span class="line">String base = <span class="string">"@&amp;%#MX8OLTI!?)=+;:,^.'-"</span>;<span class="comment">//从复杂到简单</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">img = ImageIO.read(<span class="keyword">new</span> File(picPath));</span><br><span class="line"><span class="keyword">int</span> width = img.getWidth();</span><br><span class="line"><span class="keyword">int</span> height = img.getHeight();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y += <span class="number">4</span>) {</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x += <span class="number">4</span>) {</span><br><span class="line"><span class="keyword">int</span> pixel = img.getRGB(x, y);</span><br><span class="line"><span class="keyword">int</span> r = (pixel &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, g = (pixel &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, b = pixel &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">double</span> gray = <span class="number">0.299f</span> * r + <span class="number">0.578f</span> * g + <span class="number">0.114f</span> * b;</span><br><span class="line"><span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor(gray * base.length() / <span class="number">256</span>);</span><br><span class="line"><span class="keyword">char</span> symbol = base.charAt(index);</span><br><span class="line">jt.append(symbol+<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//System.out.print(symbol+" ");</span></span><br><span class="line">}</span><br><span class="line">jt.append(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line">}</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//窗口显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFrame</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">//显示Image</span></span><br><span class="line">JLabel jl=<span class="keyword">new</span> JLabel(); <span class="comment">//创建一个标签</span></span><br><span class="line">ImageIcon image = <span class="keyword">new</span> ImageIcon(<span class="string">"D:\\#Study resources\\#Stream\\1583853509270.jpg"</span>);</span><br><span class="line">image.setImage(image.getImage().getScaledInstance(image.getIconHeight()/<span class="number">2</span>, image.getIconWidth()/<span class="number">2</span>,Image.SCALE_SMOOTH ));</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口设置</span></span><br><span class="line">Toolkit toolkit = Toolkit.getDefaultToolkit();<span class="comment">//添加工具包</span></span><br><span class="line">jf.setSize(image.getIconHeight(), image.getIconWidth());</span><br><span class="line"><span class="keyword">int</span> x = (<span class="keyword">int</span>)(toolkit.getScreenSize().getWidth()-jf.getWidth())/<span class="number">2</span>;<span class="comment">//屏幕居中显示</span></span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">int</span>)(toolkit.getScreenSize().getHeight()-jf.getHeight())/<span class="number">2</span>;</span><br><span class="line">jf.setLocation(x, y);</span><br><span class="line">jp.setBackground(Color.white);    <span class="comment">//设置背景色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示时间</span></span><br><span class="line">timeLabel = <span class="keyword">new</span> JLabel(<span class="string">"CurrentTime: "</span>);</span><br><span class="line">timedisplay = <span class="keyword">new</span> JLabel();</span><br><span class="line">configTimeArea();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将组件添加到窗口</span></span><br><span class="line">jt.setSize(image.getIconHeight(), image.getIconWidth());</span><br><span class="line">jt.setFont(<span class="keyword">new</span> Font(<span class="string">"宋体"</span>,<span class="number">20</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">jf.add(jp);</span><br><span class="line">jp.add(timeLabel);<span class="comment">//添加时间标签</span></span><br><span class="line">jp.add(timedisplay);<span class="comment">//添加时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jl.setIcon(image);//添加图片到标签</span></span><br><span class="line"><span class="comment">//jp.add(jl);    //将标签添加到面板</span></span><br><span class="line"></span><br><span class="line">jp.add(jt);<span class="comment">//将字符图片添加到面板</span></span><br><span class="line">drawPic();</span><br><span class="line"></span><br><span class="line">jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式</a></h2><blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a href="https://www.runoob.com/design-pattern/factory-pattern.html">工厂模式</a></h3></blockquote><ul><li><p><strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p></li><li><p><strong>主要解决</strong>：主要解决接口选择的问题。</p></li><li><p><strong>何时使用</strong>：我们明确地计划不同条件下创建不同实例时。</p></li><li><p><strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品。</p></li><li><p><strong>关键代码</strong>：创建过程在其子类执行。</p></li><li><p><strong>应用实例</strong>： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p></li><li><p><strong>优点</strong>： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p></li><li><p><strong>缺点</strong>：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p></li><li><p><strong>使用场景</strong>： </p></li></ul><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li><li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ol><ul><li><strong>注意事项</strong>：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>创建一个接口:</li></ol><ul><li>shape.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape {</span><br><span class="line">   void draw();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="2"><li>创建实现接口的实体类。</li></ol><ul><li>Rectangle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Inside Rectangle::draw() method.");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>Square.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Inside Square::draw() method.");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>Circle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Inside Circle::draw() method.");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li>创建一个工厂，生成基于给定信息的实体类的对象。</li></ol><ul><li>ShapeFactory.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory {</span><br><span class="line">    </span><br><span class="line">   //使用 getShape 方法获取形状类型的对象</span><br><span class="line">   public Shape getShape(String shapeType){</span><br><span class="line">      if(shapeType == null){</span><br><span class="line">         return null;</span><br><span class="line">      }        </span><br><span class="line">      if(shapeType.equalsIgnoreCase("CIRCLE")){</span><br><span class="line">         return new Circle();</span><br><span class="line">      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){</span><br><span class="line">         return new Rectangle();</span><br><span class="line">      } else if(shapeType.equalsIgnoreCase("SQUARE")){</span><br><span class="line">         return new Square();</span><br><span class="line">      }</span><br><span class="line">      return null;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="4"><li>使用该工厂，通过传递类型信息来获取实体类的对象。</li></ol><ul><li>FactoryPatternDemo.java</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPatternDemo {</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) {</span><br><span class="line">      ShapeFactory shapeFactory = new ShapeFactory();</span><br><span class="line"> </span><br><span class="line">      //获取 Circle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape1 = shapeFactory.getShape("CIRCLE");</span><br><span class="line"> </span><br><span class="line">      //调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape2 = shapeFactory.getShape("RECTANGLE");</span><br><span class="line"> </span><br><span class="line">      //调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line"> </span><br><span class="line">      //获取 Square 的对象，并调用它的 draw 方法</span><br><span class="line">      Shape shape3 = shapeFactory.getShape("SQUARE");</span><br><span class="line"> </span><br><span class="line">      //调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>执行程序，输出结果：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br></pre></td></tr></tbody></table></figure></li></ol><blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3></blockquote><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><ul><li><p><strong>意图</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p></li><li><p><strong>主要解决</strong>：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p></li><li><p><strong>何时使用</strong>：在不想增加很多子类的情况下扩展类。</p></li><li><p><strong>如何解决</strong>：将具体功能职责划分，同时继承装饰者模式。</p></li><li><p><strong>关键代码</strong>： </p></li></ul><ol><li>Component 类充当抽象角色，不应该具体实现。 </li><li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li></ol><ul><li><strong>应用实例</strong>： </li></ul><ol><li>孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 </li><li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li></ol><ul><li><p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li><li><p><strong>缺点</strong>：多层装饰比较复杂。</p></li><li><p><strong>使用场景</strong>： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p></li><li><p><strong>注意事项</strong>：可代替继承。</p></li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol><li>创建一个接口:</li></ol><ul><li>shape.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape {</span><br><span class="line">   void draw();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="2"><li>创建实现接口的实体类。</li></ol><ul><li>Rectangle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Shape: Rectangle");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>Circle.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape {</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      System.out.println("Shape: Circle");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li>创建实现了 Shape 接口的抽象装饰类。</li></ol><ul><li>ShapeFactory.java<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ShapeDecorator implements Shape {</span><br><span class="line">   protected Shape decoratedShape;</span><br><span class="line"> </span><br><span class="line">   public ShapeDecorator(Shape decoratedShape){</span><br><span class="line">      this.decoratedShape = decoratedShape;</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   public void draw(){</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">   }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="4"><li>创建扩展了 ShapeDecorator 类的实体装饰类。</li></ol><ul><li>RedShapeDecorator.java</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedShapeDecorator extends ShapeDecorator {</span><br><span class="line"> </span><br><span class="line">   public RedShapeDecorator(Shape decoratedShape) {</span><br><span class="line">      super(decoratedShape);     </span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() {</span><br><span class="line">      decoratedShape.draw();         </span><br><span class="line">      setRedBorder(decoratedShape);</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   private void setRedBorder(Shape decoratedShape){</span><br><span class="line">      System.out.println("Border Color: Red");</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>使用 RedShapeDecorator 来装饰 Shape 对象。</li></ol><p>DecoratorPatternDemo.java</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DecoratorPatternDemo {</span><br><span class="line">   public static void main(String[] args) {</span><br><span class="line"> </span><br><span class="line">      Shape circle = new Circle();</span><br><span class="line">      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());</span><br><span class="line">      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());</span><br><span class="line">      //Shape redCircle = new RedShapeDecorator(new Circle());</span><br><span class="line">      //Shape redRectangle = new RedShapeDecorator(new Rectangle());</span><br><span class="line">      System.out.println("Circle with normal border");</span><br><span class="line">      circle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println("\nCircle of red border");</span><br><span class="line">      redCircle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println("\nRectangle of red border");</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>执行程序，输出结果：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Circle with normal border</span><br><span class="line">Shape: Circle</span><br><span class="line"></span><br><span class="line">Circle of red border</span><br><span class="line">Shape: Circle</span><br><span class="line">Border Color: Red</span><br><span class="line"></span><br><span class="line">Rectangle of red border</span><br><span class="line">Shape: Rectangle</span><br><span class="line">Border Color: Red</span><br></pre></td></tr></tbody></table></figure><h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h3></li></ol><blockquote><h4 id="情景模拟"><a href="#情景模拟" class="headerlink" title="情景模拟"></a>情景模拟</h4></blockquote><p>我们还是拿汽车来举例子吧。<br>现在的汽车越来越智能化了，什么定速巡航、自动刹车、车道偏离等功能都逐渐进入我们的生活，为我们带来了更为便利的出行。</p><p>假设上述提到的定速巡航、自动刹车、车道偏离三个功能就是我们想要为汽车装饰的功能，汽车默认的功能配置有：基本配置。</p><p>得到具体的汽车（宝马、奥迪、奔驰）后，我们可以选择性地增加装饰功能。</p><blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">class Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">virtual void show() = 0;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 三个实体的汽车类</span><br><span class="line">class Bmw :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "这是一辆宝马汽车，配置有：基本配置";</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">class Audi :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "这是一辆奥迪汽车，配置有：基本配置";</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">class Benz :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "这是一辆奔驰汽车，配置有：基本配置";</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 装饰器1 定速巡航</span><br><span class="line">class Decorator01 :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Decorator01(Car* p) :pCar(p) {}</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">pCar-&gt;show();</span><br><span class="line">cout &lt;&lt; "，定速巡航";</span><br><span class="line">}</span><br><span class="line">private:</span><br><span class="line">Car* pCar;</span><br><span class="line">};</span><br><span class="line">// 装饰器2 自动刹车</span><br><span class="line">class Decorator02 :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Decorator02(Car* p) :pCar(p) {}</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">pCar-&gt;show();</span><br><span class="line">cout &lt;&lt; "，自动刹车";</span><br><span class="line">}</span><br><span class="line">private:</span><br><span class="line">Car* pCar;</span><br><span class="line">};</span><br><span class="line">// 装饰器3 定速巡航</span><br><span class="line">class Decorator03 :public Car</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Decorator03(Car* p) :pCar(p) {}</span><br><span class="line">void show()</span><br><span class="line">{</span><br><span class="line">pCar-&gt;show();</span><br><span class="line">cout &lt;&lt; "，车道偏离";</span><br><span class="line">}</span><br><span class="line">private:</span><br><span class="line">Car* pCar;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">Car* p1 = new Decorator01(new Bmw());</span><br><span class="line">p1 = new Decorator02(p1);</span><br><span class="line">p1 = new Decorator03(p1);</span><br><span class="line">p1-&gt;show();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Car* p2 = new Decorator02(new Audi());</span><br><span class="line">p2-&gt;show();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Car* p3 = new Decorator03(new Benz());</span><br><span class="line">p3-&gt;show();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4></blockquote><p>可以看到，我们在运行代码中：<br>给宝马汽车增加了Decorator01（定速巡航）、Decorator02（自动刹车）、Decorator03（车道偏离）的配置；<br>给奥迪汽车增加了Decorator02（自动刹车）配置；<br>给奔驰汽车增加了Decorator03（车道偏离）配置。</p><blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a></h3></blockquote><p><code>单例模式（Singleton Pattern）</code><br>是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><ul><li><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></li><li><p><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</p></li><li><p><strong>何时使用</strong>：当您想控制实例数目，节省系统资源的时候。</p></li><li><p><strong>如何解决</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p></li><li><p><strong>关键代码</strong>：构造函数是私有的。</p></li><li><p><strong>应用实例</strong>：</p></li></ul><ol><li>一个班级只有一个班主任。</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ol><ul><li><strong>优点</strong>：</li></ul><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><ul><li><strong>缺点</strong>：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li></ul><blockquote><h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3></blockquote><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>懒汉式的特点是延迟加载，比如配置文件，采用懒汉式的方法，顾名思义，懒汉么，很懒的，配置文件的实例直到用到的时候才会加载。</p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式的特点是一开始就加载了，如果说懒汉式是“时间换空间”，那么饿汉式就是“空间换时间”，因为一开始就创建了实例，所以每次用到的之后直接返回就好了。</p><blockquote><h3 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h3></blockquote><ul><li><strong>意图</strong>：定义对象间的一种一对多的以来管辖，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li><li><strong>主要解决</strong>：一个对象状态改变给其他对象通知的问题</li><li><strong>何时使用</strong>：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板</title>
      <link href="2021/05/22/%E6%A8%A1%E6%9D%BF/"/>
      <url>2021/05/22/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板是一种类型进行参数化的工具，通常有两种形式</p><ul><li><p><strong>函数模板</strong></p><ul><li>函数模板针对仅参数类型不同的函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename type&gt; return-type</span><br><span class="line">func-name(parameter list)</span><br><span class="line">{</span><br><span class="line">   // 函数体</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//例：</span><br><span class="line"></span><br><span class="line">template &lt;typename T1,typename T2&gt; </span><br><span class="line">auto add(T1 a, T2 b)</span><br><span class="line">{</span><br><span class="line">    return a+b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>类模板</strong></p><ul><li>类模板针对仅数据成员和函数成员类型不同的类<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename type&gt; class 类名</span><br><span class="line">{</span><br><span class="line">    // 类定义</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>模板的声明或定义只能在全局，命名空间或类范围内进行</p></li><li><p>实例化</p><ul><li>函数模板只是蓝图，本身不是不是类型、函数</li><li>编译器扫描代码，遇到模版定义时，并不立即产生代码</li><li>确定模板实参后，编译器生成实际函数代码</li></ul></li><li><p>确定模板实参的方法</p><ul><li><strong>显式实例化</strong></li></ul><p>  强制某些函数实例化，可出现于程序中模板定义后的任何位置。</p><ul><li><strong>隐式实例化</strong></li></ul><p>  编译器查看函数调用，推断模版实参，实现隐式实例化。</p></li></ul><h4 id="实例函数-实例类"><a href="#实例函数-实例类" class="headerlink" title="实例函数/实例类"></a>实例函数/实例类</h4><p>由函数模板实例化得到的函数叫做“实例函数”，由类模板实例化得到的类叫做“实例类”</p><h4 id="默认类型模板参数"><a href="#默认类型模板参数" class="headerlink" title="默认类型模板参数"></a>默认类型模板参数</h4><p>类模板的类型形参可以有默认值，函数模板的类型形参则不能</p><p>函数模板和类模板都可以为模板的非类型形参提供默认值</p><p>类模板的类型形参的默认值形式为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1,typename T2 = int&gt; class Demo</span><br><span class="line">{</span><br><span class="line">  ...  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="友元模板函数"><a href="#友元模板函数" class="headerlink" title="友元模板函数"></a>友元模板函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?</span><br></pre></td></tr></tbody></table></figure><h4 id="多态的模板实现"><a href="#多态的模板实现" class="headerlink" title="多态的模板实现"></a>多态的模板实现</h4><ul><li>虚函数多态，是动态绑定，运行时多态，使用继承、虚函数，基类指针实现透明的处理不同类型集合的方法</li></ul><ol><li>能够优雅的处理一个包含有不同类型的集合</li><li>可执行代码量通常比较小</li><li>可以对代码进行完全编译；因此不需要发布源码</li></ol><ul><li>模板多态，是静多态</li></ul><h4 id="模板特化和偏特化"><a href="#模板特化和偏特化" class="headerlink" title="模板特化和偏特化"></a>模板特化和偏特化</h4><ul><li><p><strong>模板特化</strong>：是指对于模板参数是特定的类型，可以为编译器指定特定的实现</p></li><li><p><strong>模板偏特化</strong>：当有多个模板参数时，可以为部分模板参数指定特定的类型来进行特化</p></li><li><p>函数模板只支持全特化</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">class Test</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Test(T1 i, T2 j) :a(i), b(j) { std::cout &lt;&lt; "模板类" &lt;&lt; std::endl; }</span><br><span class="line">private:</span><br><span class="line">T1 a;</span><br><span class="line">T2 b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Test&lt;int, char&gt;</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Test(int i, char j) :a(i), b(j) { std::cout &lt;&lt; "全特化" &lt;&lt; std::endl; }</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template &lt;typename T2&gt;</span><br><span class="line">class Test&lt;char, T2&gt;</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">Test(char i, T2 j) :a(i), b(j) { std::cout &lt;&lt; "偏特化" &lt;&lt; std::endl; }</span><br><span class="line">private:</span><br><span class="line">char a;</span><br><span class="line">T2 b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">//////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//模板函数</span><br><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">void fun(T1 a, T2 b)</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; "模板函数" &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//全特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">void fun&lt;int, char &gt;(int a, char b)</span><br><span class="line">{</span><br><span class="line">std::cout &lt;&lt; "全特化" &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//函数不存在偏特化：下面的代码是错误的</span><br><span class="line">/*</span><br><span class="line">template&lt;typename T2&gt;</span><br><span class="line">void fun&lt;char,T2&gt;(char a, T2 b)</span><br><span class="line">{</span><br><span class="line">cout&lt;&lt;"偏特化"&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">Test&lt;double, double&gt; t1(0.1, 0.2);</span><br><span class="line">Test&lt;int, char&gt; t2(1, 'A');</span><br><span class="line">Test&lt;char, bool&gt; t3('A', true);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h4></li><li><p>c++模板是一种新的编程范式</p></li><li><p>借助模板参数推理和模板特化</p></li><li><p>将运行期行为用编译期来模拟，最主要的两个点：</p></li></ul><ol><li>用模板特化来模拟运行期的分支判断</li><li>用模板参数递归匹配来模拟运行期的循环流程<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int a_1, int ...a_n&gt;</span><br><span class="line">struct MinValue {</span><br><span class="line">static const int value = a_1 &gt; MinValue&lt;a_n...&gt;::value ? MinValue&lt;a_n...&gt;::value : a_1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;int a, int b&gt;</span><br><span class="line">struct MinValue&lt;a, b&gt; {</span><br><span class="line">static const int value = MinValue&lt;a&gt;::value &lt; MinValue&lt;b&gt;::value ? MinValue&lt;a&gt;::value : MinValue&lt;b&gt;::value;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">//这个版本是需要的</span><br><span class="line">template&lt;int a&gt;</span><br><span class="line">struct MinValue&lt;a&gt; {</span><br><span class="line">static const int value = a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;int a_1, int ...a_n&gt;</span><br><span class="line">struct MaxValue {</span><br><span class="line">static const int value = a_1 &lt; MaxValue&lt;a_n...&gt;::value ? MaxValue&lt;a_n...&gt;::value : a_1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;int a, int b&gt;</span><br><span class="line">struct MaxValue&lt;a, b&gt; {</span><br><span class="line">static const int value = a &gt; b ? a : b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这个版本不需要</span><br><span class="line">// template&lt;int a&gt;</span><br><span class="line">// struct MaxValue&lt;a&gt; {</span><br><span class="line">//  static const int  value = a;</span><br><span class="line">// };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">//编译期查找最大最小值</span><br><span class="line">const int maxResult = MaxValue&lt;8, 5, 2, 10, 6, 1, 9&gt;::value;</span><br><span class="line">const int minResult = MinValue&lt;8, 5, 2, 10, 6, 1, 9&gt;::value;</span><br><span class="line">std::cout &lt;&lt; "MaxValue:" &lt;&lt; maxResult &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; "MinValue:" &lt;&lt; minResult &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><p>声明与实现放在一起</p><h4 id="非泛型编程"><a href="#非泛型编程" class="headerlink" title="非泛型编程"></a>非泛型编程</h4><p>声明与实现分离</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="2021/05/22/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/05/22/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式有如下优点：</p><ul><li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li><li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li><li>在需要的时间和地点实现功能闭包，使程序更灵活。<h4 id="lambda-表达式的概念和基本用法"><a href="#lambda-表达式的概念和基本用法" class="headerlink" title="lambda 表达式的概念和基本用法"></a>lambda 表达式的概念和基本用法</h4>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。<br>lambda 表达式的语法形式可简单归纳如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ 捕获列表 ] ( 参数表 ) 函数选项 -&gt; 返回值类型 { 函数体 };</span><br><span class="line"></span><br><span class="line">//简单例子 </span><br><span class="line">auto f = [](int a) -&gt; int { return a + 1; };</span><br><span class="line">std::cout &lt;&lt; f(1) &lt;&lt; std::endl;  // 输出: 2</span><br></pre></td></tr></tbody></table></figure>省略 lambda 表达式的返回值定义：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f = [](int a){ return a + 1; };</span><br></pre></td></tr></tbody></table></figure>↑ 这样编译器就会根据 return 语句自动推导出返回值类型。<br>需要注意</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x1 = [](int i){ return i; };  // OK: return type is int</span><br><span class="line">auto x2 = [](){ return { 1, 2 }; };  // error: 无法推导出返回值类型</span><br></pre></td></tr></tbody></table></figure><p>另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f1 = [](){ return 1; };</span><br><span class="line">auto f2 = []{ return 1; };  // 省略空参数表</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-lambda-表达式捕获列表"><a href="#使用-lambda-表达式捕获列表" class="headerlink" title="使用 lambda 表达式捕获列表"></a>使用 lambda 表达式捕获列表</h4><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p><ul><li>[] 不捕获任何变量。</li><li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li>[=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li>[=，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li><li>[this] 捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li></ul><p>lambda表达式的基本用法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class XX</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    int i = 0;</span><br><span class="line">    void func(int x, int y)</span><br><span class="line">    {</span><br><span class="line">        auto x1 = [] { return i; };                    // error，没有捕获外部变量</span><br><span class="line">        auto x2 = [=] { return i + x + y; };           // OK，捕获所有外部变量</span><br><span class="line">        auto x3 = [&amp;] { return i + x + y; };           // OK，捕获所有外部变量</span><br><span class="line">        auto x4 = [this] { return i; };                // OK，捕获this指针</span><br><span class="line">        auto x5 = [this] { return i + x + y; };        // error，没有捕获x、y</span><br><span class="line">        auto x6 = [this, x, y] { return i + x + y; };  // OK，捕获this指针、x、y</span><br><span class="line">        auto x7 = [this] { return i++; };              // OK，捕获this指针，并修改成员的值</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int a = 0, b = 1;</span><br><span class="line">auto f1 = [] { return a; };               // error，没有捕获外部变量</span><br><span class="line">auto f2 = [&amp;] { return a++; };            // OK，捕获所有外部变量，并对a执行自加运算</span><br><span class="line">auto f3 = [=] { return a; };              // OK，捕获所有外部变量，并返回a</span><br><span class="line">auto f4 = [=] { return a++; };            // error，a是以复制方式捕获的，无法修改</span><br><span class="line">auto f5 = [a] { return a + b; };          // error，没有捕获变量b</span><br><span class="line">auto f6 = [a, &amp;b] { return a + (b++); };  // OK，捕获a和b的引用，并对b做自加运算</span><br><span class="line">auto f7 = [=, &amp;b] { return a + (b++); };  // OK，捕获所有外部变量和b的引用，并对b做自加运算</span><br></pre></td></tr></tbody></table></figure><h4 id="lambda-表达式的类型"><a href="#lambda-表达式的类型" class="headerlink" title="lambda 表达式的类型"></a>lambda 表达式的类型</h4><p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure       Type）”。它是一个特殊的，匿名的非 nunion 的类类型。</p><p>因此，我们可以认为它是一个带有 operator() 的类，即仿函数。</p><p>因此，我们可以使用 std::function 和 std::bind 来存储和操作 lambda 表达式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;int(int)&gt;  f1 = [](int a){ return a; };</span><br><span class="line">std::function&lt;int(void)&gt; f2 = std::bind([](int a){ return a; }, 123);</span><br></pre></td></tr></tbody></table></figure><p>另外，对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using func_t = int(*)(int);</span><br><span class="line">func_t f = [](int a){ return a; };</span><br><span class="line">f(123);</span><br></pre></td></tr></tbody></table></figure><p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。</p><p>而一个使用了成员变量的类的operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。</p><p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的operator()默认是const的</p><p>一个const成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。</p><p>需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而捕获变量的 lambda 表达式则不能转换为函数指针。看看下面的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Ptr)(int*);</span><br><span class="line">Ptr p = [](int* p){delete p;};  // 正确，没有状态的lambda（没有捕获）的lambda表达式可以直接转换为函数指针</span><br><span class="line">Ptr p1 = [&amp;](int* p){delete p;};  // 错误，有状态的lambda不能直接转换为函数指针</span><br></pre></td></tr></tbody></table></figure><p>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于windows系统的多线程</title>
      <link href="2021/05/22/%E5%9F%BA%E4%BA%8Ewindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/05/22/%E5%9F%BA%E4%BA%8Ewindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="睡眠排序法"><a href="#睡眠排序法" class="headerlink" title="睡眠排序法"></a>睡眠排序法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Created on Apple Pencil.</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define max(a,b)  a&gt;b? a:b;</span><br><span class="line"></span><br><span class="line">void sleepsort(int i)</span><br><span class="line">{</span><br><span class="line">    Sleep(i*100);</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; ",";</span><br><span class="line">}</span><br><span class="line">int main() {</span><br><span class="line"></span><br><span class="line">    int item[] = { 10,1,3,4,9,4,2,5,3,20};</span><br><span class="line">    int Max = item[0];</span><br><span class="line">    for (int i = 0; i &lt; sizeof(item) &gt;&gt; 2; i++)</span><br><span class="line">    {</span><br><span class="line">        Max = max(Max, item[i]);</span><br><span class="line">    }</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    {</span><br><span class="line">        thread test(sleepsort,item[i]);</span><br><span class="line">        test.detach();</span><br><span class="line">    }</span><br><span class="line">    Sleep(Max*110);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++多线程"></a>C++多线程</h2><ul><li>创建一个线程，不做处理会调用abort函数终止程序</li><li><code>join()</code>函数加入，汇合线程,阻塞主线程,等待子线程执行结束，才会回到主线程中</li><li>一个线程只能join一次</li><li><code>detach()</code>函数 分离，打破依赖关系,把子线程驻留后台</li><li>当线程detach之后，就不能再join了</li><li><code>joinable()</code>判断当前进程是否可以做join或者detach过程，可以则返回true，不可以则返回false<h4 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//线程处理函数</span><br><span class="line">void print_1()</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--子线程1运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">void print_2()</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--子线程2运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">void print_3()</span><br><span class="line">{</span><br><span class="line">Sleep(5000);</span><br><span class="line">cout &lt;&lt; "--子线程3运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class thr</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">void operator ()()</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--子线程thr运行--" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">//创建线程</span><br><span class="line">thread test(print_1);</span><br><span class="line"></span><br><span class="line">test.join();</span><br><span class="line"></span><br><span class="line">thread test_2(print_2);</span><br><span class="line">test_2.join();</span><br><span class="line"></span><br><span class="line">thread test_3(print_3);</span><br><span class="line">test_3.detach();</span><br><span class="line"></span><br><span class="line">thr th;</span><br><span class="line">thread test_4(th);</span><br><span class="line">test_4.join();</span><br><span class="line"></span><br><span class="line">auto lambdathread = []</span><br><span class="line">{</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--lambda线程运行--" &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">thread test_5(lambdathread);</span><br><span class="line">test_5.join();</span><br><span class="line"></span><br><span class="line">Sleep(1000);</span><br><span class="line">if (test_3.joinable())</span><br><span class="line">{</span><br><span class="line">test_3.detach();</span><br><span class="line">}</span><br><span class="line">else {</span><br><span class="line">cout &lt;&lt; "子线程3已被处理" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Sleep(1000);</span><br><span class="line">cout &lt;&lt; "--主线程运行--" &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>vector容器装载线程<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void myprint(int i)</span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt;"--thread_num:"&lt;&lt; i &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">int main() </span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; "--主线程执行--" &lt;&lt; endl;</span><br><span class="line">    vector &lt;thread&gt; mythreads;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    {</span><br><span class="line">        mythreads.push_back(thread(myprint, i));</span><br><span class="line">        //mythreads[i].join();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (auto tp = mythreads.begin(); tp != mythreads.end(); ++tp)</span><br><span class="line">    {</span><br><span class="line">        //cout &lt;&lt; tp-&gt;get_id() &lt;&lt; endl;</span><br><span class="line">        tp-&gt;join();</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; "--主线程结束--" &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="- 互斥量mutex"></a>- 互斥量mutex</h3><ul><li>互斥量是个类对象，理解成一把锁，多个线程尝试用lock()成员函数来加锁这个锁，只有一个线程能够锁定成功，成功的标志是lock()函数返回</li><li>如果没锁成功，那么流程会卡在lock()这里不断地尝试去锁</li><li>互斥量使用时要注意，保护数据要合适，少了没达到保护效果，多了影响效率</li></ul><h4 id="互斥量的用法"><a href="#互斥量的用法" class="headerlink" title="互斥量的用法"></a>互斥量的用法</h4><ul><li>步骤：先lock(),操作共享数据，再unlock();</li><li>lock()和unlock()要一对一成对使用，每调用一次lock()必然调用一个unlock()</li><li>std::lock_guard类模板：忘记unlock不要紧，guard帮你unlock()</li><li>智能指针(unique_ptr&lt;&gt;)：你忘记释放内存不要紧，ta也帮你释放</li><li>std::lock_guard 可以取代lock()和unlock(),就是使用了lock_guard之后，不能使用lock()和unlock()之中任何一个</li></ul><blockquote><p>原理：</p></blockquote><ul><li>lock_guard构造函数里执行了mutex::lock()</li><li>lock_guard析构函数里执行了mutex::unlock()<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::lock_guard&lt;std::mutex&gt; my_guard(my_mutex);</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// Created on Apple Pencil.</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">list &lt;int&gt; DataQueue;</span><br><span class="line"></span><br><span class="line">class mythread {</span><br><span class="line">public:</span><br><span class="line">    void indata()</span><br><span class="line">    {</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; __FUNCTION__"执行，插入数据" &lt;&lt;i&lt;&lt; endl;</span><br><span class="line">            lock_guard&lt;mutex&gt; myguard(mymutex);</span><br><span class="line">            //mymutex.lock();</span><br><span class="line">            DataQueue.push_back(i);</span><br><span class="line">            //mymutex.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    void outdata()</span><br><span class="line">    {</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++)</span><br><span class="line">        {</span><br><span class="line">            if (!DataQueue.empty())</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; __FUNCTION__"执行，读出数据" &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                mymutex.lock();</span><br><span class="line">                int command = DataQueue.front();</span><br><span class="line">                DataQueue.pop_front();</span><br><span class="line">                mymutex.unlock();</span><br><span class="line">            }</span><br><span class="line">            else</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; __FUNCTION__"继续执行，但消息队列为空" &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">private:</span><br><span class="line">    mutex mymutex;//创建了一个互斥量</span><br><span class="line">};</span><br><span class="line">int main() </span><br><span class="line">{</span><br><span class="line">    mythread mt;</span><br><span class="line">    thread myindata(&amp;mythread::indata,&amp;mt);</span><br><span class="line">    thread myoutdata(&amp;mythread::outdata, &amp;mt);</span><br><span class="line">    myindata.join();</span><br><span class="line">    myoutdata.join();</span><br><span class="line">    cout &lt;&lt; "--主线程结束--" &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li>死锁前提条件是要有两把锁（两个互斥量）</li><li>现有两个线程A、B，两把锁1、2</li></ul><ol><li>线程A执行的时候，线程先锁1.lock()成功,然后去执行2.lock()[未锁]</li><li>出现了上下文切换</li><li>线程B执行了，但是这个线程先锁2.lock()了，因为此时2.lock还没有被锁，所以2.lock()成功，线程B要去执行1.lock()</li><li>此时此刻，死锁产生了</li><li>线程A因为拿不到2.lock(),流程走不下去，所以1.不能unlock()</li><li>线程B因为拿不到1.lock(),流程走不下去，所以2.不能unlock()</li></ol><h3 id="死锁的一般解决方案"><a href="#死锁的一般解决方案" class="headerlink" title="死锁的一般解决方案"></a>死锁的一般解决方案</h3><p>只要保证这两个互斥量上锁的顺序一致就不会死锁</p><h3 id="std-lock-函数模板"><a href="#std-lock-函数模板" class="headerlink" title="std::lock()函数模板"></a>std::lock()函数模板</h3><p><code>std::lock(my_mutex1,my_mutex2);</code></p><ul><li>一次锁住两个或以上的互斥量</li><li>不存在因为多个线程中因为锁的顺序问题产生的死锁</li><li>如果互斥量中有一个没锁住，它就在那等着，等到所有的互斥量都锁柱，它才会继续往下走(返回)</li><li>要么两个互斥量都锁柱，要么都没锁柱。如果只锁了一个，另外一个没锁成功，则它立即把已经锁住的解锁</li></ul><h3 id="std-adopt-lock"><a href="#std-adopt-lock" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h3><ul><li>std::adopt_lock是个结构体对象,起标记作用，表示这个互斥量已经lock(),不需要在std::lock_guard<a href="std::mutex">std::mutex</a>里面对对象进行再次lock()了;<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::lock_guard&lt;mutex&gt; my_guard1(my_mutex1,std::adopt_lock);</span><br><span class="line">std::lock_guard&lt;mutex&gt; my_guard2(my_mutex2,std::adopt_lock);</span><br></pre></td></tr></tbody></table></figure><h3 id="Read-Write"><a href="#Read-Write" class="headerlink" title="Read_Write"></a>Read_Write</h3><blockquote><p>读者写者是一个非常著名的同步问题。读者写者问题描述非常简单，有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者在读文件时写者也不去能写文件。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;mutex&gt;</span><br><span class="line">#include&lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">mutex Write_mutex;</span><br><span class="line">list&lt;char&gt; buffer_area;</span><br><span class="line">queue&lt;int&gt; Read_queue;//读者队列</span><br><span class="line"></span><br><span class="line">void Write()</span><br><span class="line">{</span><br><span class="line">while (1)</span><br><span class="line">{</span><br><span class="line">if (Read_queue.empty())//如果读者队列为空，写者才能开始写</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "写者写文件" &lt;&lt; endl;</span><br><span class="line">Write_mutex.lock();//写者写的时候上锁，读者不能读</span><br><span class="line">buffer_area.push_back('#');</span><br><span class="line">Write_mutex.unlock();//写完解锁</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">void Read(int k)</span><br><span class="line">{</span><br><span class="line">while (1)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "读者" &lt;&lt; k &lt;&lt; "读文件" &lt;&lt; buffer_area.size() &lt;&lt; endl;</span><br><span class="line">int *q = new int(1);</span><br><span class="line">Read_queue.push(*q);//加入读者队列</span><br><span class="line">Write_mutex.lock();//读者读时上锁</span><br><span class="line">Write_mutex.unlock();//读完解锁</span><br><span class="line">delete q;</span><br><span class="line">Read_queue.pop();//读完退出读者队列</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">//可以添加读者</span><br><span class="line">thread myReader1(Read,1);//读者1</span><br><span class="line">thread myReader2(Read,2);//读者2</span><br><span class="line">thread myReader3(Read,3);//读者3</span><br><span class="line">thread myWriter(Write);</span><br><span class="line"></span><br><span class="line">myWriter.detach();</span><br><span class="line">myReader1.detach();</span><br><span class="line">myReader2.detach();</span><br><span class="line">myReader3.detach();</span><br><span class="line">Sleep(1000);</span><br><span class="line">return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="2021/05/22/%E5%BC%82%E5%B8%B8/"/>
      <url>2021/05/22/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a><a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">异常</a></h2><p><strong>Error Code</strong></p><ul><li>基于Error Code的错误处理<ul><li>被调用函数发生错误时返回错误码</li><li>函数调用方检查并处理错误码</li></ul></li><li>痛点<ul><li>代码繁琐，错误处理和业务逻辑耦合</li><li>错误码表现力不足</li><li>容易被忽略</li><li>有的特殊函数没有返回值（构造函数，赋值操作符等）</li></ul></li></ul><p><strong>关键词</strong></p><p><code>exception, throw, try/catch</code></p><p><strong>抛出异常</strong></p><blockquote><p>您可以使用 throw 语句在代码块中的任何地方抛出异常。throw语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double division(int a, int b)</span><br><span class="line">{</span><br><span class="line">   if( b == 0 )</span><br><span class="line">   {</span><br><span class="line">      throw "Division by zero condition!";</span><br><span class="line">   }</span><br><span class="line">   return (a/b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>捕获异常</strong></p><blockquote><p>catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由catch关键字后的括号内的异常声明决定的。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">{</span><br><span class="line">   // 保护代码</span><br><span class="line">}catch( ExceptionName e )</span><br><span class="line">{</span><br><span class="line">  // 处理 ExceptionName 异常的代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>实例</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">double division(int a, int b)</span><br><span class="line">{</span><br><span class="line">   if( b == 0 )</span><br><span class="line">   {</span><br><span class="line">      throw "Division by zero condition!";</span><br><span class="line">   }</span><br><span class="line">   return (a/b);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">{</span><br><span class="line">   int x = 50;</span><br><span class="line">   int y = 0;</span><br><span class="line">   double z = 0;</span><br><span class="line"> </span><br><span class="line">   try {</span><br><span class="line">     z = division(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   }catch (const char* msg) {</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>运行结果</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Division by zero condition!</span><br></pre></td></tr></tbody></table></figure><p><strong>捕获多种类型异常</strong></p><ul><li>多个catch块</li><li>不发生隐式转换</li><li>支持子类转基类对象</li></ul><p><strong>捕获所有异常</strong>  </p><p><code>catch(...)</code></p><p>Catch块中的那些事儿</p><ul><li>错误恢复<ul><li>如果可以，如果有必要</li></ul></li><li>记录错误<ul><li>如果有必要</li></ul></li><li>向上返回<ul><li>返回错误码</li><li>重新抛出异常</li></ul></li></ul><p><strong>异常捕获链</strong></p><ul><li>异常抛出后程序执行将立即跳转至最近的try块的最后，按顺序匹配catch块并执行；</li><li>相应的catch块执行后异常被处理，程序继续执行；</li><li>若无匹配的catch块则继续跳转至下一个最近的try块进行处理；</li><li>若当前函数中异常未被处理，则退出该函数（stack unwinding），在其调用函数中进行处理；</li><li>递归以上步骤支持异常被处理；</li><li>若跳转至最顶层依然无匹配的catch块，则程序退出;</li></ul><p><strong>捕获Windows SEH异常</strong><br>__try/__except</p><p><strong>异常总结</strong></p><ul><li>优点<ul><li>隔离异常处理代码</li><li>异常无法被忽略</li><li>构造函数可以报错</li></ul></li><li>缺点<ul><li>写异常安全的代码并不简单</li><li>错误现场易丢失</li><li>性能损失（现代编译器可能问题不大）</li><li>编译出的二进制文件体积较大</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="2021/05/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2021/05/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h4 id="指针的痛点"><a href="#指针的痛点" class="headerlink" title="指针的痛点"></a>指针的痛点</h4><ul><li>忘记delete，内存泄漏</li><li>野指针访问，行为未定义（内存访问异常）</li><li>多次delete，行为未定义</li></ul><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><a href="http://c.biancheng.net/view/7909.html">unique_ptr</a></h4><ul><li>同一时刻只能有一个 unique_ptr 指向给对象</li><li>unique_ptr 指针的生命周期从创建时开始，直到离开作用域。离开作用域时，若其指向对象，则其所指对象销毁</li><li>unique_ptr 的使用能够包括：</li></ul><ol><li>为动态申请的内存提供异常安全</li><li>将动态申请内存的所有权传递给某个函数</li><li>从某个函数返回动态申请内存的所有权</li><li>在容器中保存指针</li><li>所有auto_ptr具有的功能<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    {</span><br><span class="line">        std::unique_ptr&lt;int&gt; uptr(new int(10));  //绑定动态对象</span><br><span class="line">        //std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能賦值</span><br><span class="line">        //std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷貝</span><br><span class="line">        std::unique_ptr&lt;int&gt; uptr2 = std::move(uptr); //轉換所有權</span><br><span class="line">        uptr2.release(); //释放所有权</span><br><span class="line">    }</span><br><span class="line">    //超過uptr的作用域，內存釋放</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><a href="http://c.biancheng.net/view/7898.html">shared_ptr</a></h4></li></ol><ul><li><p>shared_ptr (共享资源的只能指针)被用来表示共享的拥有权。也就是说两段代码都需要访问一些数据，而他们又都没有独占该数据的所有权(从某种意义上来说就是该段代码负责销毁该对象)</p></li><li><p>shared_ptr 是一种计数指针。当引用计数变为0时，shared_ptr所指向的对象就会被删除。</p></li><li><p>在给shared_ptr分配内存时建议使用 make_shared 函数，这样最安全</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    {</span><br><span class="line">        int a = 10;</span><br><span class="line">        std::shared_ptr&lt;int&gt; ptra = std::make_shared&lt;int&gt;(a);</span><br><span class="line">        std::shared_ptr&lt;int&gt; ptra2(ptra); //copy</span><br><span class="line">        std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        int b = 20;</span><br><span class="line">        int *pb = &amp;a;</span><br><span class="line">        //std::shared_ptr&lt;int&gt; ptrb = pb;  //error</span><br><span class="line">        std::shared_ptr&lt;int&gt; ptrb = std::make_shared&lt;int&gt;(b);</span><br><span class="line">        ptra2 = ptrb; //assign</span><br><span class="line">        pb = ptrb.get(); //获取原始指针</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; ptrb.use_count() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak-ptr"></a><a href="http://c.biancheng.net/view/7918.html">weak-ptr</a></h4></li><li><p>弱指针(weak pointer) ，指向一个已经用shared_ptr进行管理的对象</p></li><li><p>只有当对象存在的时候，才需要对其进行访问</p></li><li><p>可能被其他人删除释放，且在最后一次使用之后调用其析构函数(通常用于释放那些不具名的内存(anon-memory)资源</p></li><li><p>weak_ptr可以保存一个“弱引用”，引用一个已经用shared_ptr管理的对象。为了访问这个对象一个weak_ptr可以通过shared_ptr的构造函数或者是weak_ptr的成员函数lock()转化为一个shared_ptr。当最后一个指向这个对象的shared_ptr退出其生命周期并且这个对象被释放之后,将无法从指向这个对象的weak_ptr获得一个shared_ptr指针,shared_ptr的构造函数会抛出异常，而weak_ptr::lock也会返回一个空指针。</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    {</span><br><span class="line">        std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10);</span><br><span class="line">        std::cout &lt;&lt; sh_ptr.use_count() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::weak_ptr&lt;int&gt; wp(sh_ptr);</span><br><span class="line">        std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        if(!wp.expired()){</span><br><span class="line">            std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //get another shared_ptr</span><br><span class="line">            *sh_ptr = 100;</span><br><span class="line">            std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    //delete memory</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="智能指针的痛点"><a href="#智能指针的痛点" class="headerlink" title="智能指针的痛点"></a>智能指针的痛点</h4><ul><li>使用场景复杂</li><li>原生指针、智能指针混用的坑</li><li>无法杜绝原生指针的使用<ul><li>历史代码</li><li>跨模块使用方式</li></ul></li><li>其他原因</li><li>总结：没有在语言级别解决问题</li></ul><h4 id="指针使用"><a href="#指针使用" class="headerlink" title="指针使用"></a>指针使用</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//unique_ptr ---管理独占对象</span><br><span class="line">unique_ptr&lt;int&gt; foo(new int(5));</span><br><span class="line">cout &lt;&lt; foo &lt;&lt; endl;</span><br><span class="line">foo.reset(new int(6));</span><br><span class="line">cout &lt;&lt; foo &lt;&lt; endl;</span><br><span class="line">auto foo1 = make_unique&lt;int&gt;(*foo);</span><br><span class="line">cout &lt;&lt; foo1 &lt;&lt; endl;</span><br><span class="line">foo.release();</span><br><span class="line">cout &lt;&lt; foo &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//shared_ptr ---管理的对象可以共享</span><br><span class="line">shared_ptr&lt;int&gt; foo2(new int(6));</span><br><span class="line">cout &lt;&lt; "foo2.use_count(): \t"&lt;&lt;foo2.use_count() &lt;&lt; endl;</span><br><span class="line">shared_ptr&lt;int&gt; foo3(foo2);</span><br><span class="line">cout &lt;&lt; "foo2.use_count(): \t" &lt;&lt; foo2.use_count() &lt;&lt; endl;</span><br><span class="line">auto foo4 = make_shared&lt;int&gt;(5);</span><br><span class="line">cout &lt;&lt; "foo4.unique(): \t\t" &lt;&lt; foo4.unique() &lt;&lt; endl;</span><br><span class="line">foo4 = move(foo2);</span><br><span class="line">cout &lt;&lt; "foo2.use_count(): \t" &lt;&lt; foo2.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo4.use_count(): \t" &lt;&lt; foo4.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo4.unique(): \t\t" &lt;&lt; foo4.unique() &lt;&lt; endl;</span><br><span class="line">foo4.~shared_ptr();</span><br><span class="line">cout &lt;&lt; "foo4.use_count(): \t" &lt;&lt; foo4.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo3.use_count(): \t" &lt;&lt; foo3.use_count() &lt;&lt; endl;</span><br><span class="line">foo3.~shared_ptr();</span><br><span class="line">cout &lt;&lt; "foo4.use_count(): \t" &lt;&lt; foo4.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo3.use_count(): \t" &lt;&lt; foo3.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//weak_ptr ---指向一个已经用shared_ptr进行管理的对象</span><br><span class="line">shared_ptr&lt;int&gt; foo5(new int(6));</span><br><span class="line">cout &lt;&lt; "foo5.use_count(): \t" &lt;&lt; foo5.use_count() &lt;&lt; endl;</span><br><span class="line">weak_ptr&lt;int&gt; foo6(foo5);</span><br><span class="line">cout &lt;&lt; "foo5.use_count(): \t" &lt;&lt; foo5.use_count() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo6.use_count(): \t" &lt;&lt; foo6.use_count() &lt;&lt; endl;</span><br><span class="line">auto foo7(foo5);</span><br><span class="line">cout &lt;&lt; "foo5\t\t\t" &lt;&lt; foo5 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo6.lock()\t\t" &lt;&lt; foo6.lock() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo6.use_count(): \t" &lt;&lt; foo6.use_count() &lt;&lt; endl;</span><br><span class="line">foo5.reset();</span><br><span class="line">cout &lt;&lt; "foo6.expired()\t\t" &lt;&lt; foo6.expired() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo6.lock()\t\t" &lt;&lt; foo6.lock() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo6.use_count(): \t" &lt;&lt; foo6.use_count() &lt;&lt; endl;</span><br><span class="line">foo7.reset();</span><br><span class="line">cout &lt;&lt; "foo6.expired()\t\t" &lt;&lt; foo6.expired() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo6.lock()\t\t" &lt;&lt; foo6.lock() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "foo6.use_count(): \t" &lt;&lt; foo6.use_count() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">00E44CB8</span><br><span class="line">00E44CE8</span><br><span class="line">00E44CB8</span><br><span class="line">00000000</span><br><span class="line"></span><br><span class="line">foo2.use_count():       1</span><br><span class="line">foo2.use_count():       2</span><br><span class="line">foo4.unique():          1</span><br><span class="line">foo2.use_count():       0</span><br><span class="line">foo4.use_count():       2</span><br><span class="line">foo4.unique():          0</span><br><span class="line">foo4.use_count():       1</span><br><span class="line">foo3.use_count():       1</span><br><span class="line">foo4.use_count():       -572662307</span><br><span class="line">foo3.use_count():       -572662307</span><br><span class="line"></span><br><span class="line">foo5.use_count():       1</span><br><span class="line">foo5.use_count():       1</span><br><span class="line">foo6.use_count():       1</span><br><span class="line">foo5                    00E44D18</span><br><span class="line">foo6.lock()             00E44D18</span><br><span class="line">foo6.use_count():       2</span><br><span class="line">foo6.expired()          0</span><br><span class="line">foo6.lock()             00E44D18</span><br><span class="line">foo6.use_count():       1</span><br><span class="line">foo6.expired()          1</span><br><span class="line">foo6.lock()             00000000</span><br><span class="line">foo6.use_count():       0</span><br></pre></td></tr></tbody></table></figure><h4 id="手写shared-ptr"><a href="#手写shared-ptr" class="headerlink" title="手写shared_ptr"></a>手写shared_ptr</h4><p>可能有些不完善</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Swap(T&amp; t1, T&amp; t2)</span><br><span class="line">{</span><br><span class="line">    T temp;</span><br><span class="line">    temp = t1;</span><br><span class="line">    t1 = t2;</span><br><span class="line">    t2 = temp;</span><br><span class="line">}</span><br><span class="line">class Shared_count {</span><br><span class="line">public:</span><br><span class="line">    Shared_count()</span><br><span class="line">    {</span><br><span class="line">        count = 0;</span><br><span class="line">    }</span><br><span class="line">    void add_count() // 增加计数</span><br><span class="line">    {</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">    void reduce_count() // 减少计数</span><br><span class="line">    {</span><br><span class="line">        count--;</span><br><span class="line">    }</span><br><span class="line">    int get_count() const // 获取当前计数</span><br><span class="line">    {</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line">    operator int()</span><br><span class="line">    {</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line">private:</span><br><span class="line">    int count;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Shared_ptr {</span><br><span class="line">public:</span><br><span class="line">    Shared_ptr(T* pointer = nullptr) noexcept //用普通指针构造智能指针</span><br><span class="line">    {</span><br><span class="line">        this-&gt;ptr = pointer;</span><br><span class="line">        count = new Shared_count();</span><br><span class="line">        if (pointer)</span><br><span class="line">        {</span><br><span class="line">            count-&gt;add_count();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    Shared_ptr(const Shared_ptr&lt;T&gt;&amp; pointer)//用智能指针构造智能指针</span><br><span class="line">    {</span><br><span class="line">        this-&gt;ptr = pointer.ptr;</span><br><span class="line">        this-&gt;count = pointer.count;</span><br><span class="line">        count-&gt;add_count();</span><br><span class="line">    }</span><br><span class="line">    ~Shared_ptr() noexcept  // ptr不为空且此时共享计数减为0的时候,再去删除</span><br><span class="line">    {</span><br><span class="line">        count-&gt;reduce_count();</span><br><span class="line">        if (ptr &amp;&amp; !count-&gt;get_count()) </span><br><span class="line">        {</span><br><span class="line">            delete ptr;</span><br><span class="line">            delete count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 重载-&gt;操作符</span><br><span class="line">    T* operator-&gt;()const</span><br><span class="line">    {</span><br><span class="line">        return ptr;</span><br><span class="line">    }</span><br><span class="line">    // 重载*操作符</span><br><span class="line">    T&amp; operator*() const </span><br><span class="line">    {</span><br><span class="line">        return ptr;</span><br><span class="line">    }</span><br><span class="line">    T* get()</span><br><span class="line">    {</span><br><span class="line">        return ptr;</span><br><span class="line">    }</span><br><span class="line">    operator bool()</span><br><span class="line">    {</span><br><span class="line">        if (ptr != nullptr)</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    }</span><br><span class="line">    void swap(Shared_ptr&amp; sp)</span><br><span class="line">    {</span><br><span class="line">        Swap(this-&gt;ptr,sp.ptr);</span><br><span class="line">        Swap(this-&gt;count, sp.count);</span><br><span class="line">    }</span><br><span class="line">    bool unique()const</span><br><span class="line">    {</span><br><span class="line">        if (count-&gt;get_count())</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return true;</span><br><span class="line">    }</span><br><span class="line">    void reset(T* pointer = nullptr)</span><br><span class="line">    {</span><br><span class="line">        this-&gt;ptr = pointer;</span><br><span class="line">        count = new Shared_count();</span><br><span class="line">        if (pointer)</span><br><span class="line">        {</span><br><span class="line">            count-&gt;add_count();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    int use_count()</span><br><span class="line">    {</span><br><span class="line">        return count-&gt;get_count();</span><br><span class="line">    }</span><br><span class="line">    Shared_ptr&amp; operator=(const Shared_ptr&lt;T&gt;&amp; pointer)</span><br><span class="line">    {</span><br><span class="line">        if (this != &amp;pointer)// 判断是否自赋值</span><br><span class="line">        {</span><br><span class="line">            this-&gt;count = pointer.count;</span><br><span class="line">            this-&gt;ptr = pointer.ptr;</span><br><span class="line">            count-&gt;add_count();</span><br><span class="line">        }</span><br><span class="line">        return *this;</span><br><span class="line">    }</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp; output, const Shared_ptr&amp; S)</span><br><span class="line">    {</span><br><span class="line">        output &lt;&lt; ptr;</span><br><span class="line">        return ptr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    T* ptr;</span><br><span class="line">    Shared_count* count;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="2021/05/22/STL/"/>
      <url>2021/05/22/STL/</url>
      
        <content type="html"><![CDATA[<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a><a href="http://c.biancheng.net/stl/">STL</a></h2><blockquote><p>Standard Template Library</p></blockquote><table><thead><tr><th align="center"><div style="width:110px">类别</div></th><th>解释</th></tr></thead><tbody><tr><td align="center">容器(containers)</td><td>特殊的数据结构，实现了数组链表队列等等，实质是模板类</td></tr><tr><td align="center">迭代器(iterators)</td><td>一种复杂的指针，可以通过其读写容器中的对象，实质是运算符重载</td></tr><tr><td align="center">空间配置器(allocator)</td><td>容器的空间配置管理的模板类</td></tr><tr><td align="center">配接器(adapters)</td><td>用来修饰容器、仿函数、迭代器接口</td></tr><tr><td align="center">算法(algorithms)</td><td>读写容器对象的逻辑算法：排序，便利，查找，等等实质是模板函数</td></tr><tr><td align="center">仿函数(functors)</td><td>类似函数，通过重载()运算符来模拟函数行为的类</td></tr></tbody></table><blockquote><h3 id="STL-容器种类和功能"><a href="#STL-容器种类和功能" class="headerlink" title="STL 容器种类和功能"></a>STL 容器种类和功能</h3></blockquote><table><thead><tr><th align="center"><div style="width:80px">类别</div></th><th>解释</th></tr></thead><tbody><tr><td align="center">序列容器</td><td>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td></tr><tr><td align="center">排序容器</td><td>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td></tr><tr><td align="center">哈希容器</td><td>C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td></tr></tbody></table><blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3></blockquote><p>迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。</p><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。</p><blockquote><p>输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。</p></blockquote><p><strong>前向迭代器（forward iterator）</strong><br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p><p><strong>双向迭代器（bidirectional iterator）</strong><br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p><p><strong>随机访问迭代器（random access iterator）</strong><br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><ul><li>p+=i：使得 p 往后移动 i 个元素。</li><li>p-=i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><h3 id="C-11-标准中不同容器指定使用的迭代器类型。"><a href="#C-11-标准中不同容器指定使用的迭代器类型。" class="headerlink" title="C++ 11 标准中不同容器指定使用的迭代器类型。"></a>C++ 11 标准中不同容器指定使用的迭代器类型。</h3><table><thead><tr><th>容器</th><th>对应的迭代器类型</th><th>应用</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td><td></td></tr><tr><td>stack</td><td>不支持迭代器</td><td>后进先出容器</td></tr><tr><td>queue</td><td>不支持迭代器</td><td>先进先出容器</td></tr><tr><td>vector</td><td>随机访问迭代器</td><td>直接访问任意元素，快速插入、删除尾部元素</td></tr><tr><td>deque</td><td>随机访问迭代器</td><td>直接访问任意元素，快速插入、删除头部和尾部元素</td></tr><tr><td>list</td><td>双向迭代器</td><td>快速插入、删除任意位置元素</td></tr><tr><td>set / multiset</td><td>双向迭代器</td><td>快速查询元素，无重复关键字/允许重复关键字</td></tr><tr><td>map / multimap</td><td>双向迭代器</td><td>Key/value pair mapping(键值对映射)。不允许重复关键字/允许重复关键字，使用关键字快速查询元素</td></tr><tr><td>forward_list</td><td>前向迭代器</td><td></td></tr><tr><td>unordered_map / unordered_multimap</td><td>前向迭代器</td><td></td></tr><tr><td>unordered_set / unordered_multiset</td><td>前向迭代器</td><td></td></tr></tbody></table><h3 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h3><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式<br>|迭代器定义方式|具体格式|<br>|——–|——–|<br>|正向迭代器    |容器类名::iterator  迭代器名;|<br>|常量正向迭代器    |容器类名::const_iterator  迭代器名;|<br>|反向迭代器    |容器类名::reverse_iterator  迭代器名;|<br>|常量反向迭代器    |容器类名::const_reverse_iterator  迭代器名;|</p><h3 id="排序后迭代器访问list"><a href="#排序后迭代器访问list" class="headerlink" title="排序后迭代器访问list"></a>排序后迭代器访问list</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List-&gt;sort();</span><br><span class="line">for (list&lt;int&gt;::iterator iter = List-&gt;begin(); iter != List-&gt;end(); iter++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; *iter &lt;&lt; " ";</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><h3 id="一级容器的通用函数"><a href="#一级容器的通用函数" class="headerlink" title="一级容器的通用函数"></a>一级容器的通用函数</h3><table><thead><tr><th><div style="width:120px">Functions</div></th><th>Description</th></tr></thead><tbody><tr><td>c1.swap(c2)</td><td>交换两个容器c1和c2的内容</td></tr><tr><td>c1.max_size()</td><td>返回一个容器可以容纳的最大元素数量</td></tr><tr><td>c.clear()</td><td>删除容器中的所有元素</td></tr><tr><td>c.begin()</td><td>返回容器首元素的迭代器</td></tr><tr><td>c.end()</td><td>返回容器尾元素之后位置的迭代器</td></tr><tr><td>c.rbegin()</td><td>返回容器为元素的迭代器，用于逆序遍历</td></tr><tr><td>c.rend()</td><td>返回容器首元素之前位置的迭代器，用于逆序遍历</td></tr><tr><td>c.erase(beg, end)</td><td>删除容器中从beg到end-1之间的元素。beg和end都是迭代器</td></tr></tbody></table><h3 id="顺序容器通用函数"><a href="#顺序容器通用函数" class="headerlink" title="顺序容器通用函数"></a>顺序容器通用函数</h3><table><thead><tr><th><div style="width:120px">Functions</div></th><th>Description</th></tr></thead><tbody><tr><td>assign(n, elem)</td><td>将指定元素的n份拷贝加入(赋值)到容器中</td></tr><tr><td>assign(beg,end)</td><td>将迭代器[beg,end)间的元素赋值给当前容器</td></tr><tr><td>push_back(elem)</td><td>将元素附加到容器</td></tr><tr><td>pop_back()</td><td>删除容器尾元素</td></tr><tr><td>front()</td><td>返回容器首元素</td></tr><tr><td>back()</td><td>返回容器尾元素</td></tr><tr><td>insert(position,elem)</td><td>将元素插入到容器指定位置</td></tr></tbody></table><h3 id="关联容器通用函数"><a href="#关联容器通用函数" class="headerlink" title="关联容器通用函数"></a>关联容器通用函数</h3><table><thead><tr><th><div style="width:140px">Functions</div></th><th>Description</th></tr></thead><tbody><tr><td>find(key)</td><td>搜索容器中具有key的元素，返回指向该元素的迭代器</td></tr><tr><td>lower_bound(key)</td><td>搜索容器中具有key的第一个元素，返回指向该元素的迭代器</td></tr><tr><td>upper_bound(key)</td><td>搜索容器中具有key的最后一个元素，返回指向此元素之后位置的迭代器</td></tr><tr><td>count(key)</td><td>返回容器中具有key的元素的数目</td></tr></tbody></table><h3 id="迭代器支持的运算符"><a href="#迭代器支持的运算符" class="headerlink" title="迭代器支持的运算符"></a>迭代器支持的运算符</h3><table><thead><tr><th>类别</th><th>运算符</th></tr></thead><tbody><tr><td>All iterators</td><td>++p</td></tr><tr><td>All iterators</td><td>p++</td></tr><tr><td>Input iterators</td><td>*p</td></tr><tr><td>Input iterators</td><td>p1==p2</td></tr><tr><td>Input iterators</td><td>p1!=p2</td></tr><tr><td>Output iterators</td><td>*p</td></tr><tr><td>Bidirectionl iterators</td><td>–p</td></tr><tr><td>Bidirectionl iterators</td><td>p–</td></tr><tr><td>Random access iterators</td><td>p+=i</td></tr><tr><td>Random access iterators</td><td>p-=i</td></tr><tr><td>Random access iterators</td><td>p+i</td></tr><tr><td>Random access iterators</td><td>p-i</td></tr><tr><td>Random access iterators</td><td>p1&lt;p2</td></tr><tr><td>Random access iterators</td><td>p1&lt;=p2</td></tr><tr><td>Random access iterators</td><td>p1&gt;p2</td></tr><tr><td>Random access iterators</td><td>p1&gt;=p2</td></tr><tr><td>Random access iterators</td><td>p[i]</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A(Input iterators) --&gt;C(Forward iterators)</span><br><span class="line">B(Output iterators) --&gt;C(Forward iterators)</span><br><span class="line">C(Forward iterators)--&gt;D(Bidirectional iterators)</span><br><span class="line">D(Bidirectional iterators)--&gt;E(Random access  iterators)</span><br></pre></td></tr></tbody></table></figure><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><ul><li>优先队列元素按其优先级(priority) 读取，默认使用 &lt; 运算符来比较元素</li><li>默认基于vector实现。也可基于<br>deque，但不能用list<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;float&gt; q;</span><br><span class="line">q.push(22.22);</span><br><span class="line">q.push(66.66);</span><br><span class="line">q.push(44.44);</span><br><span class="line">cout &lt;&lt; q.top();</span><br><span class="line"></span><br><span class="line">output:66.66</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="遍历-vector-容器。"><a href="#遍历-vector-容器。" class="headerlink" title="//遍历 vector 容器。"></a>//遍历 vector 容器。</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    vector&lt;int&gt; v{1,2,3,4,5,6,7,8,9,10}; //v被初始化成有10个元素</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; i = 0; i &lt; v.size(); ++i)</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt;" ";</span><br><span class="line">    //创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; "第二种遍历方法：" &lt;&lt; endl;</span><br><span class="line">    vector&lt;int&gt;::iterator i;</span><br><span class="line">    //用 != 比较两个迭代器</span><br><span class="line">    for (i = v.begin(); i != v.end(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; " ";</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; "第三种遍历方法：" &lt;&lt; endl;</span><br><span class="line">    for (i = v.begin(); i &lt; v.end(); ++i) //用 &lt; 比较两个迭代器</span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; " ";</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; "第四种遍历方法：" &lt;&lt; endl;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    while (i &lt; v.end()) </span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; " ";</span><br><span class="line">        i += 2; // 随机访问迭代器支持 "+= 整数"  的操作</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="STL的精华——萃取（trait）"><a href="#STL的精华——萃取（trait）" class="headerlink" title="STL的精华——萃取（trait）"></a>STL的精华——萃取（trait）</h2><blockquote><p>当函数，类或者一些封装的通用算法中的某些部分会因为数据类型不同而导致处理或逻辑不同（而我们又不希望因为数据类型的差异而修改算法本身的封装时），traits会是一种很好的解决方案。</p></blockquote><p>函数参数列表接受两个迭代器，累加两个迭代器之间的数据，假定迭代器指向的数据类型是T，迭代器类型为Iter。</p><p>声明如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Iter, typename T&gt;</span><br><span class="line">T sum(Iter begin, Iter end)</span><br><span class="line">{</span><br><span class="line">T result {};</span><br><span class="line">while (begin != end) {</span><br><span class="line">result += *begin++;</span><br><span class="line">}</span><br><span class="line">return result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">{</span><br><span class="line">vector&lt;int&gt; vi { 1, 2, 3, 4 };</span><br><span class="line">vector&lt;string&gt; vs { "ha", "sa", "ki" };</span><br><span class="line"></span><br><span class="line">int s = sum&lt;vector&lt;int&gt;::iterator, int&gt;(vi.begin(), vi.end());</span><br><span class="line">string s2 = sum&lt;vector&lt;string&gt;::iterator, string&gt;(vs.begin(), vs.end());</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="什么是萃取，为什么要萃取"><a href="#什么是萃取，为什么要萃取" class="headerlink" title="什么是萃取，为什么要萃取"></a>什么是萃取，为什么要萃取</h3><p>有没有办法只用一个类型参数，就实现上面的函数？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Iter&gt;</span><br><span class="line">typename Iter::value_type sum(Iter begin, Iter end)</span><br><span class="line">{</span><br><span class="line">typename Iter::value_type result {};</span><br><span class="line">while (begin != end) {</span><br><span class="line">result += *begin++;</span><br><span class="line">}</span><br><span class="line">return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>value_type就是属于迭代器的一个特性，迭代器可以随时随地获取到自己的特性，这个就是萃取。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Category, class T, class Distance = ptrdiff_t,</span><br><span class="line">class Pointer = T*, class Reference = T&amp;&gt;</span><br><span class="line">struct iterator</span><br><span class="line">{</span><br><span class="line">    typedef Categoryiterator_category;</span><br><span class="line">    typedef Tvalue_type;</span><br><span class="line">    typedef Distancedifference_type;</span><br><span class="line">    typedef Pointerpointer;</span><br><span class="line">    typedef Referencereference;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template&lt;class Iterator&gt;</span><br><span class="line">struct iterator_traits</span><br><span class="line">{</span><br><span class="line">    typedef typename Iterator::iterator_categoryiterator_category;</span><br><span class="line">    typedef typename Iterator::value_typevalue_type;</span><br><span class="line">    typedef typename Iterator::difference_typedifference_type;</span><br><span class="line">    typedef typename Iterator::pointerpointer;</span><br><span class="line">    typedef typename Iterator::reference reference;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>迭代器类别、指向的数据类型都是萃取出来的特性。</p><h2 id="无处不在的特化——为了提高性能无所不用其极"><a href="#无处不在的特化——为了提高性能无所不用其极" class="headerlink" title="无处不在的特化——为了提高性能无所不用其极"></a>无处不在的特化——为了提高性能无所不用其极</h2><p>以下就对以数组指针作为迭代器实现的类型做了偏特化，指定迭代器类别为随机迭代器，这样就可以对这些数组指针使用专属于随机迭代器的方法。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct iterator_traits&lt;T*&gt;</span><br><span class="line">{</span><br><span class="line">    typedef random_access_iterator_tag iterator_category;</span><br><span class="line">    typedef T value_type;</span><br><span class="line">    typedef ptrdiff_t difference_type;</span><br><span class="line">    typedef T*pointer;</span><br><span class="line">    typedef T&amp; reference;</span><br><span class="line">};</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct iterator_traits&lt;const T*&gt;</span><br><span class="line">{</span><br><span class="line">    typedef random_access_iterator_tag iterator_category;</span><br><span class="line">    typedef T value_type;</span><br><span class="line">    typedef ptrdiff_t difference_type;</span><br><span class="line">    typedef const T*pointer;</span><br><span class="line">    typedef const T&amp; reference;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>对于不同的数据类型，copy的实现也是大不相同的，对于POD（Plain Old Data，普通旧数据，如int，char，double），memcpy就是最高效的copy方式，对于类对象可能要通过拷贝构造函数才能完整复制一个对象。那怎么针对不同的数据类型采用不同的方式拷贝方式呢？答案依然是特化。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class InputIterator, class OutputIterator&gt;</span><br><span class="line">OutputIterator __copy(InputIterator first, InputIterator last, OutputIterator result, _true_type){</span><br><span class="line">    auto dist = distance(first, last);</span><br><span class="line">    memcpy(result, first, sizeof(*first) * dist);</span><br><span class="line">    advance(result, dist);</span><br><span class="line">    return result;</span><br><span class="line">}</span><br><span class="line">template&lt;class InputIterator, class OutputIterator&gt;</span><br><span class="line">OutputIterator __copy(InputIterator first, InputIterator last, OutputIterator result, _false_type){</span><br><span class="line">    while (first != last){</span><br><span class="line">        *result = *first;</span><br><span class="line">        ++result;</span><br><span class="line">        ++first;</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">}</span><br><span class="line">template&lt;class InputIterator, class OutputIterator, class T&gt;</span><br><span class="line">OutputIterator _copy(InputIterator first, InputIterator last, OutputIterator result, T*){</span><br><span class="line">    typedef typename TinySTL::_type_traits&lt;T&gt;::is_POD_type is_pod;</span><br><span class="line">    return __copy(first, last, result, is_pod());</span><br><span class="line">}</span><br><span class="line">template &lt;class InputIterator, class OutputIterator&gt;</span><br><span class="line">OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result){</span><br><span class="line">    return _copy(first, last, result, value_type(first));</span><br><span class="line">}</span><br><span class="line">template&lt;&gt;</span><br><span class="line">inline char *copy(char *first, char *last, char *result){</span><br><span class="line">    auto dist = last - first;</span><br><span class="line">    memcpy(result, first, sizeof(*first) * dist);</span><br><span class="line">    return result + dist;</span><br><span class="line">}</span><br><span class="line">template&lt;&gt;</span><br><span class="line">inline wchar_t *copy(wchar_t *first, wchar_t *last, wchar_t *result){</span><br><span class="line">    auto dist = last - first;</span><br><span class="line">    memcpy(result, first, sizeof(*first) * dist);</span><br><span class="line">    return result + dist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="内存拷贝函数memcpy"><a href="#内存拷贝函数memcpy" class="headerlink" title="内存拷贝函数memcpy"></a>内存拷贝函数memcpy</h3><p>原型：void*memcpy(void*dest, const void*src,unsigned int count); </p><p>功能：由src所指内存区域复制count个字节到dest所指内存区域。  </p><p>说明：src和dest所指内存区域不能重叠，函数返回指向dest的指针。    </p><h2 id="参考STL源码"><a href="#参考STL源码" class="headerlink" title="参考STL源码"></a><a href="https://github.com/zouxiaohang/TinySTL.git">参考STL源码</a></h2><p>这是一个简易版的STL实现，适用于初学者研究STL的设计思想。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2021/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2021/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="各种内部排序方法比较"><a href="#各种内部排序方法比较" class="headerlink" title="各种内部排序方法比较"></a>各种内部排序方法比较</h2><table><thead><tr><th>类别</th><th>排序</th><th>best</th><th>normal</th><th>worst</th><th>辅助空间</th><th>稳定性</th><th>比较次数</th><th>交换次数</th></tr></thead><tbody><tr><td>插入</td><td>插入排序</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>n-1,n(n-1)/2</td><td>0,n(n-1)/2</td></tr><tr><td>插入</td><td>希尔排序</td><td>O(n)</td><td>O(n^1.3)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>?</td><td>?</td></tr><tr><td>选择</td><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>n(n-1)/2</td><td>0,n-1</td></tr><tr><td>选择</td><td>堆排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>不稳定</td><td>nlog2n</td><td>?</td></tr><tr><td>交换</td><td>冒泡排序</td><td>O(n)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>n-1,n(n-1)/2</td><td>0,n(n-1)/2</td></tr><tr><td>交换</td><td>快速排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n²)</td><td>O(nlog2n)</td><td>不稳定</td><td>nlog2n,n(n-1)/2</td><td>?</td></tr><tr><td></td><td>归并排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n)</td><td>稳定</td><td>nlog2n/2</td><td>?</td></tr><tr><td></td><td>基数排序</td><td>O(d(n+rd)</td><td>O(d(n+rd))</td><td>O(d(n+rd))</td><td>O(rd+n)</td><td>稳定</td><td>?</td><td>?</td></tr></tbody></table><p>注：基数排序中d代表长度，r代表关键字基数，n代表关键字个数</p><h2 id="背景及字体颜色"><a href="#背景及字体颜色" class="headerlink" title="背景及字体颜色"></a>背景及字体颜色</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">//背景颜色： </span><br><span class="line">//0 黑色  </span><br><span class="line">//1 蓝色 </span><br><span class="line">//2 绿色 </span><br><span class="line">//3 湖蓝色 </span><br><span class="line">//4 红色 </span><br><span class="line">//5 紫色 </span><br><span class="line">//6 黄色</span><br><span class="line">//7 白色</span><br><span class="line">//8 灰色</span><br><span class="line">//9 淡蓝色</span><br><span class="line">void BackGround(unsigned int ForeColor=7,unsigned int BackGroundColor=0) </span><br><span class="line">{</span><br><span class="line">    HANDLE handle=GetStdHandle(STD_OUTPUT_HANDLE);  </span><br><span class="line">    SetConsoleTextAttribute(handle,ForeColor+BackGroundColor*0x10);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="HuffmanTreeCode"><a href="#HuffmanTreeCode" class="headerlink" title="HuffmanTreeCode"></a>HuffmanTreeCode</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define MAX 1000 //哈夫曼树最大结点个数</span><br><span class="line">#define MAXW 1000 //权值最大</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//哈夫曼树结点结构</span><br><span class="line">typedef struct HNode</span><br><span class="line">{</span><br><span class="line">char data; //数据,非叶节点为NULL</span><br><span class="line">double weight;//权重</span><br><span class="line">int parent;//双亲，-1表示没有双亲，即根节点</span><br><span class="line">int lchild;//左孩子，数组下标,-1表示无左孩子，即叶节点</span><br><span class="line">int rchild;//右孩子</span><br><span class="line">}Hnode;</span><br><span class="line"></span><br><span class="line">//编码结构</span><br><span class="line">typedef struct HuffmanCodeNode</span><br><span class="line">{</span><br><span class="line">char data; //数据</span><br><span class="line">string code;//该字符编码</span><br><span class="line">}HuffmanCodenode;</span><br><span class="line"></span><br><span class="line">//两个最小结点下标</span><br><span class="line">typedef struct minnodes</span><br><span class="line">{</span><br><span class="line">int m1;//两者更小权值结点下标</span><br><span class="line">int m2;</span><br><span class="line">bool flag;//若找到则为true,否则为false，false说明仅有一个结点</span><br><span class="line">}Minnodes;</span><br><span class="line"></span><br><span class="line">//辅助标志数组 标记该结点为根的树是否已加入哈夫曼树</span><br><span class="line">bool flag[MAX] = { false };</span><br><span class="line"></span><br><span class="line">Hnode HuffmanTree[MAX];//哈夫曼树</span><br><span class="line">HuffmanCodeNode HuffmanCode[MAX];//哈夫曼编码数组</span><br><span class="line"></span><br><span class="line">//选择两棵最小权值的树 参数max，当前有权值结点下标+1</span><br><span class="line">minnodes Select(int max)</span><br><span class="line">{</span><br><span class="line">double min = MAXW;</span><br><span class="line">minnodes mins;</span><br><span class="line">mins.m2 = -1;</span><br><span class="line"></span><br><span class="line">//查找第一个最小权值的结点下标</span><br><span class="line">for (int i = 0; i &lt; max; i++)</span><br><span class="line">{</span><br><span class="line">if (!flag[i] &amp;&amp; HuffmanTree[i].weight &lt; min)//未加入哈夫曼树,权值更小</span><br><span class="line">{</span><br><span class="line">min = HuffmanTree[i].weight;//更新最小权值</span><br><span class="line">mins.m1 = i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">flag[mins.m1] = true;//将结点加入哈夫曼树</span><br><span class="line">min = MAXW;</span><br><span class="line"></span><br><span class="line">//查找第二个最小权值结点下标，可能不存在</span><br><span class="line">for (int i = 0; i &lt; max; i++)</span><br><span class="line">{</span><br><span class="line">if (!flag[i] &amp;&amp; HuffmanTree[i].weight &lt; min)//未加入哈夫曼树,权值更小</span><br><span class="line">{</span><br><span class="line">min = HuffmanTree[i].weight;//更新最小权值</span><br><span class="line">mins.m2 = i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">flag[mins.m2] = true;//将结点加入哈夫曼树</span><br><span class="line">if (-1 == mins.m2)//仅剩余一个结点未加入哈夫曼树</span><br><span class="line">{</span><br><span class="line">mins.flag = false;//未找到两棵最小权值树</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">mins.flag = true;</span><br><span class="line">}</span><br><span class="line">return mins;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//打印哈夫曼树</span><br><span class="line">void PrintHuffmanTree(int max)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "下标\t" &lt;&lt; "数据\t" &lt;&lt; "权重\t" &lt;&lt; "双亲\t" &lt;&lt; "左孩子\t" &lt;&lt; "右孩子" &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; max; i++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].data &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].weight &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].parent &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].lchild &lt;&lt; "\t" &lt;&lt; HuffmanTree[i].rchild &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//打印编码</span><br><span class="line">void PrintHuffmanCode(int n)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; "哈夫曼编码："&lt;&lt;endl;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; HuffmanCode[i].data &lt;&lt; ":" &lt;&lt; HuffmanCode[i].code &lt;&lt; endl;;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建哈夫曼树</span><br><span class="line">void CreateHuffmanTree()</span><br><span class="line">{</span><br><span class="line">int n;//字符个数，即哈夫曼树叶节点个数</span><br><span class="line">minnodes mins;</span><br><span class="line">cout &lt;&lt; "请输入字符个数：" &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; "请输入字符及权值：" &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line">cin &gt;&gt; HuffmanTree[i].data &gt;&gt; HuffmanTree[i].weight;</span><br><span class="line">HuffmanTree[i].lchild = -1; HuffmanTree[i].rchild = -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int i = n;</span><br><span class="line">for (;; i++)</span><br><span class="line">{</span><br><span class="line">mins = Select(i);//找到两棵根权值最小的树</span><br><span class="line">if (mins.flag == false)//仅剩余一棵树时跳出</span><br><span class="line">{</span><br><span class="line">HuffmanTree[mins.m1].parent = -1;</span><br><span class="line">break;</span><br><span class="line">}</span><br><span class="line">HuffmanTree[i].weight = HuffmanTree[mins.m1].weight + HuffmanTree[mins.m2].weight;//新加入哈夫曼树结点为两个结点权值之和</span><br><span class="line">HuffmanTree[i].data = ' ';</span><br><span class="line">HuffmanTree[mins.m1].parent = i;                                //两个权值最小结点双亲为新加入结点</span><br><span class="line">HuffmanTree[mins.m2].parent = i;</span><br><span class="line">HuffmanTree[i].lchild = mins.m1;//左小又大</span><br><span class="line">HuffmanTree[i].rchild = mins.m2;</span><br><span class="line">}</span><br><span class="line">PrintHuffmanTree(i);//打印哈夫曼树</span><br><span class="line">}</span><br><span class="line">//哈夫曼编码</span><br><span class="line">void Code()</span><br><span class="line">{</span><br><span class="line">int i = 0;</span><br><span class="line">for (;; i++)//给所有叶子结点编码</span><br><span class="line">{</span><br><span class="line">int j = i;</span><br><span class="line">string str = "";</span><br><span class="line">HuffmanCode[i].data = HuffmanTree[i].data;//复制数据</span><br><span class="line">while (-1 != HuffmanTree[j].parent)//从叶节点找到根</span><br><span class="line">{</span><br><span class="line">if (HuffmanTree[HuffmanTree[j].parent].lchild == j)//左0右1</span><br><span class="line">{</span><br><span class="line">str += '0';</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">str += '1';</span><br><span class="line">}</span><br><span class="line">j = HuffmanTree[j].parent;</span><br><span class="line">}</span><br><span class="line">reverse(str.begin(), str.end());//逆序</span><br><span class="line">HuffmanCode[i].code = str;              //保存至编码</span><br><span class="line">if (HuffmanTree[i].lchild == -1 &amp;&amp; HuffmanTree[i].rchild == -1)continue;//非叶子不编码</span><br><span class="line">else break;</span><br><span class="line">}</span><br><span class="line">PrintHuffmanCode(i);</span><br><span class="line">}</span><br><span class="line">//哈夫曼树解码 从根开始，左0右1，直至叶节点</span><br><span class="line">void Encode()</span><br><span class="line">{</span><br><span class="line">string s;</span><br><span class="line">int root = 0;//记录根节点的下标</span><br><span class="line">cout &lt;&lt; "请输入01字符串:" &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">while (HuffmanTree[root].parent != -1) root++;</span><br><span class="line">int j = root;</span><br><span class="line">for (int i = 0; i &lt; s.size(); i++)//遍历输入的01串</span><br><span class="line">{</span><br><span class="line">if ('0' == s[i])</span><br><span class="line">{</span><br><span class="line">j = HuffmanTree[j].lchild;</span><br><span class="line">}</span><br><span class="line">else</span><br><span class="line">{</span><br><span class="line">j = HuffmanTree[j].rchild;</span><br><span class="line">}</span><br><span class="line">if (HuffmanTree[j].lchild == -1 &amp;&amp; HuffmanTree[j].rchild == -1)//到达叶节点</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; HuffmanTree[j].data;</span><br><span class="line">j = root;//返回根节点继续</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">//计算WPL</span><br><span class="line">void WPL()</span><br><span class="line">{</span><br><span class="line">double WPL = 0;</span><br><span class="line">for (int i = 0;; i++)</span><br><span class="line">{</span><br><span class="line">if (HuffmanTree[i].lchild != -1 || HuffmanTree[i].rchild != -1)break;</span><br><span class="line">WPL += HuffmanTree[i].weight * HuffmanCode[i].code.length();//权值×路径长度（编码长度）</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; "WPL:" &lt;&lt; WPL &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//主函数</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">int choice = 0;</span><br><span class="line">cout &lt;&lt; "----------1.创建哈夫曼树----------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------2.编码--------------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------3.解码--------------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------4.WPL---------------" &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "--------------5.退出--------------" &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "-请输入菜单序号：" &lt;&lt; endl; </span><br><span class="line">while (1)</span><br><span class="line">{</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line">switch (choice)</span><br><span class="line">{</span><br><span class="line">case 1:CreateHuffmanTree(); break;</span><br><span class="line">case 2:Code(); break;</span><br><span class="line">case 3:Encode(); break;</span><br><span class="line">case 4:WPL(); break;</span><br><span class="line">case 5:break;</span><br><span class="line">default:</span><br><span class="line">cout &lt;&lt; "输入错误：" &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="病毒感染检测（BF算法）"><a href="#病毒感染检测（BF算法）" class="headerlink" title="病毒感染检测（BF算法）"></a>病毒感染检测（BF算法）</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(<span class="keyword">const</span> string&amp; str1, <span class="keyword">const</span> string&amp; str2, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2 = str2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (str1[i] == str2[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= len2)</span><br><span class="line">        <span class="keyword">return</span> i - len2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-99</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str2 &gt;&gt; str1)</span><br><span class="line">    {</span><br><span class="line">        str1 = str1 + str1;</span><br><span class="line">        <span class="keyword">if</span> (str1 == <span class="string">"0"</span> &amp;&amp; str2 == <span class="string">"0"</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">Index_BF</span>(str1, str2, pos);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-99</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">"NO"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"YES"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="病毒感染检测（KMP算法）"><a href="#病毒感染检测（KMP算法）" class="headerlink" title="病毒感染检测（KMP算法）"></a>病毒感染检测（KMP算法）</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(string str2,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;str2.<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||str2[i]==str2[j])</span><br><span class="line">        {</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(str2[i]!=str2[j])</span><br><span class="line">                next[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i]=next[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(string &amp;str1,string &amp;str2,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=pos;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">255</span>];</span><br><span class="line">    <span class="built_in">get_next</span>(str2,next);</span><br><span class="line">    <span class="keyword">int</span> len1=str1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2=str2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||str1[i]==str2[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            j=next[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=len2)</span><br><span class="line">            <span class="keyword">return</span> i-len2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>    ;</span><br><span class="line">    string str1;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt;str2&gt;&gt;str1)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(str1==<span class="string">"0"</span>&amp;&amp;str2==<span class="string">"0"</span>)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="built_in">kmp</span>(str1,str2,pos);</span><br><span class="line">    <span class="keyword">if</span>(result!=<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">"YES"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">"NO"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="算符表达式求值"><a href="#算符表达式求值" class="headerlink" title="算符表达式求值"></a>算符表达式求值</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"><span class="keyword">char</span> priority[<span class="number">7</span>][<span class="number">7</span>]=</span><br><span class="line">{ </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'='</span>,<span class="string">'0'</span>},   <span class="comment">// "="表示左右括号相遇，括号内运算已完成 </span></span><br><span class="line">    {<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'0'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>},  </span><br><span class="line">    {<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'0'</span>,<span class="string">'='</span>}    <span class="comment">// "=" 表示整个表达式求值完毕 </span></span><br><span class="line">};                               <span class="comment">//  "0"表示不可能出现这种情况 ( 语法错误 ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Precede 用于判断运算符栈栈顶运算符 a1 与读入运算符 a2 之间的优先关系函数 </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Procede</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>{   <span class="comment">// 建立 pre[][] 到 运算符间的映射关系 </span></span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(a){  </span><br><span class="line">        <span class="keyword">case</span><span class="number">'</span>+<span class="string">':i=0;break;  </span></span><br><span class="line"><span class="string">        case'</span>-<span class="string">':i=1;break;  </span></span><br><span class="line"><span class="string">        case'</span>*<span class="string">':i=2;break;  </span></span><br><span class="line"><span class="string">        case'</span>/<span class="string">':i=3;break;  </span></span><br><span class="line"><span class="string">        case'</span>(<span class="string">':i=4;break;  </span></span><br><span class="line"><span class="string">        case'</span>)<span class="string">':i=5;break;  </span></span><br><span class="line"><span class="string">        case'</span>#<span class="string">':i=6;break;</span></span><br><span class="line"><span class="string">    }  </span></span><br><span class="line"><span class="string">    switch(b){  </span></span><br><span class="line"><span class="string">        case'</span>+<span class="string">':j=0;break;  </span></span><br><span class="line"><span class="string">        case'</span>-<span class="string">':j=1;break;  </span></span><br><span class="line"><span class="string">        case'</span>*<span class="string">':j=2;break;  </span></span><br><span class="line"><span class="string">        case'</span>/<span class="string">':j=3;break;  </span></span><br><span class="line"><span class="string">        case'</span>(<span class="string">':j=4;break;  </span></span><br><span class="line"><span class="string">        case'</span>)<span class="string">':j=5;break;  </span></span><br><span class="line"><span class="string">        case'</span>#<span class="string">':j=6;break;  </span></span><br><span class="line"><span class="string">    }  </span></span><br><span class="line"><span class="string">    return priority[i][j];  </span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">int Operate(int m,int n,char x){  </span></span><br><span class="line"><span class="string">    if(x=='</span>+<span class="string">')  </span></span><br><span class="line"><span class="string">    return m+n;  </span></span><br><span class="line"><span class="string">    if(x=='</span>-<span class="string">')  </span></span><br><span class="line"><span class="string">    return n-m;  </span></span><br><span class="line"><span class="string">    if(x=='</span>*<span class="string">')  </span></span><br><span class="line"><span class="string">    return m*n;  </span></span><br><span class="line"><span class="string">    if(x=='</span>/<span class="string">')  </span></span><br><span class="line"><span class="string">    return n/m;  </span></span><br><span class="line"><span class="string">}  </span></span><br><span class="line"><span class="string">// EvaluuateExpression-reduced</span></span><br><span class="line"><span class="string">int main(){</span></span><br><span class="line"><span class="string">    stack &lt;int&gt; OPND;  // Operand stack</span></span><br><span class="line"><span class="string">    stack &lt;char&gt; OPTR;  // Operator stack</span></span><br><span class="line"><span class="string">OPTR.push('</span>#<span class="string">');//</span></span><br><span class="line"><span class="string">    char ss[2]="#";//尾部有\0 </span></span><br><span class="line"><span class="string">    char s[100];</span></span><br><span class="line"><span class="string">    cout&lt;&lt;"输入表达式："&lt;&lt;endl; </span></span><br><span class="line"><span class="string">    cin&gt;&gt;s;</span></span><br><span class="line"><span class="string">    strcat(s,ss);// 运算式尾部加 "#"--结束运算符 </span></span><br><span class="line"><span class="string">    char c=s[0];</span></span><br><span class="line"><span class="string">    int i=1;</span></span><br><span class="line"><span class="string">    while(c!='</span>#<span class="string">'||OPTR.top()!='</span>#<span class="string">'){  //表达式未读完或者运算未完 </span></span><br><span class="line"><span class="string">        int y=0;  </span></span><br><span class="line"><span class="string">        if(c&gt;='</span><span class="number">0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>){    </span><br><span class="line">            <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>){  <span class="comment">// 读入连续的数字 </span></span><br><span class="line">                y=y*<span class="number">10</span>+(c-<span class="string">'0'</span>);  </span><br><span class="line">                c=s[i++];  </span><br><span class="line">            }  </span><br><span class="line">            OPND.<span class="built_in">push</span>(y);  <span class="comment">// 把读进的数字入数字栈 </span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(<span class="built_in">Procede</span>(OPTR.<span class="built_in">top</span>(),c))  </span><br><span class="line">            {  </span><br><span class="line">                <span class="keyword">case</span><span class="number">'</span>&lt;<span class="string">':  //栈顶元素优先权低 </span></span><br><span class="line"><span class="string">                    OPTR.push(c);  </span></span><br><span class="line"><span class="string">                    c=s[i++];  </span></span><br><span class="line"><span class="string">                    break;  </span></span><br><span class="line"><span class="string">                case'</span>=<span class="string">':  </span></span><br><span class="line"><span class="string">                    OPTR.pop();  // 脱括号 </span></span><br><span class="line"><span class="string">                    c=s[i++];  // 读入下一个字符 </span></span><br><span class="line"><span class="string">                    break;  </span></span><br><span class="line"><span class="string">                case'</span>&gt;<span class="string">':  //退栈并将运算结果入栈 </span></span><br><span class="line"><span class="string">                    char x=OPTR.top();OPTR.pop();  </span></span><br><span class="line"><span class="string">                    int m=OPND.top();OPND.pop();  </span></span><br><span class="line"><span class="string">                    int n=OPND.top();OPND.pop();  </span></span><br><span class="line"><span class="string">                    OPND.push(Operate(m,n,x));  </span></span><br><span class="line"><span class="string">                    break;    </span></span><br><span class="line"><span class="string">            } </span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    cout&lt;&lt;OPND.top();</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Josephus"><a href="#Josephus" class="headerlink" title="Josephus"></a>Josephus</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">}node;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//创建n个数据 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//初始化节点 </span></span><br><span class="line">node* p = <span class="literal">NULL</span>;</span><br><span class="line">node* head=<span class="literal">NULL</span>;</span><br><span class="line">node* s=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">head = <span class="keyword">new</span> node;</span><br><span class="line">p = head;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> ( i &lt;= n )</span><br><span class="line">{</span><br><span class="line">s = <span class="keyword">new</span> node;<span class="comment">//创建新节点 </span></span><br><span class="line">s-&gt;data = i++;</span><br><span class="line">p-&gt;next = s;<span class="comment">//链接s </span></span><br><span class="line">p = s;<span class="comment">//p指向s </span></span><br><span class="line">}</span><br><span class="line">s-&gt;next = head-&gt;next;<span class="comment">//首尾相连构成循环链表 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n, m, i,count;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"n="</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"m="</span>;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">node* p = <span class="built_in">create</span>(n);<span class="comment">//建立循环链表同时p指向首元  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != p-&gt;next)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line">p = p-&gt;next;<span class="comment">//p指向m-1个next </span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line"></span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span>(count%<span class="number">8</span>==<span class="number">0</span>)cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;<span class="comment">//p指向下一个节点</span></span><br><span class="line"></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统"></a>图书管理系统</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    string isbn;<span class="comment">//ISBN</span></span><br><span class="line">    string name;<span class="comment">//书名</span></span><br><span class="line">    <span class="keyword">double</span> price;<span class="comment">//定价</span></span><br><span class="line">} Elemtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    Book data; <span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//结点的指针域</span></span><br><span class="line">}*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p,r;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//先建立一个带头结点的空链表</span></span><br><span class="line">r=L; <span class="comment">//尾指针r指向头结点 </span></span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">"book.txt"</span>, ios::out | ios::in|ios::app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到相关文件，无法打开！"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;!file.<span class="built_in">eof</span>();)</span><br><span class="line">    {</span><br><span class="line">        p = <span class="keyword">new</span> LNode; <span class="comment">//生成新结点*p</span></span><br><span class="line">        file &gt;&gt; p-&gt;data.isbn &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price; <span class="comment">//输入元素值赋给新结点*p的数据域</span></span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = p; <span class="comment">//将新结点*p插入到尾结点*r之后</span></span><br><span class="line">r=p;<span class="comment">//r指向新的尾结点p </span></span><br><span class="line">        length++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    L = <span class="keyword">new</span> LNode; <span class="comment">//生成新结点作为头结点，用头指针L指向头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">//头结点的指针域置空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, Book &amp;e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">//初始化，p指向第一个结点，j为计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i &amp;&amp; p)   <span class="comment">//顺链域向后扫描，直到p指向第i个元素或p为空</span></span><br><span class="line">    {</span><br><span class="line">        p = p-&gt;next; <span class="comment">//p指向下一个结点</span></span><br><span class="line">        ++j; <span class="comment">//计数器j相应加1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//i值不合法i＞n或i&lt;=0</span></span><br><span class="line"></span><br><span class="line">    e = p-&gt;data; <span class="comment">//取第i个结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, string e)</span> <span class="comment">//在带头结点的单链表L中查找值为e的元素</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-&gt;next;<span class="comment">//初始化，p指向首元结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data.name != e) <span class="comment">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span></span><br><span class="line">        p = p-&gt;next; <span class="comment">//p指向下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//查找成功返回值为e的结点地址p，查找失败p为NULL</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, Book &amp;e)</span> <span class="comment">//在带头结点的单链表L中第i个位置插入值为e的新结点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    LinkList p, s;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i - <span class="number">1</span>)  <span class="comment">//查找第i-1个结点，p指向该结点</span></span><br><span class="line">    {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//i＞n+1或者i＜1</span></span><br><span class="line"></span><br><span class="line">    s = <span class="keyword">new</span> LNode; <span class="comment">//生成新结点*s</span></span><br><span class="line">    s-&gt;data = e; <span class="comment">//将结点*s的数据域置为e</span></span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">//将结点*s的指针域指向结点ai</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">//将结点*p的指针域指向结点*s</span></span><br><span class="line"></span><br><span class="line">    ++length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i)</span><span class="comment">//在带头结点的单链表L中，删除第i个位置</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p, q;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next) &amp;&amp; (j &lt; i - <span class="number">1</span>))  <span class="comment">//查找第i-1个结点，p指向该结点</span></span><br><span class="line">    {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || (j &gt; i - <span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//当i&gt;n或i&lt;1时，删除位置不合理</span></span><br><span class="line"></span><br><span class="line">    q = p-&gt;next; <span class="comment">//临时保存被删结点的地址以备释放</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">//改变删除结点前驱结点的指针域</span></span><br><span class="line">    <span class="keyword">delete</span> q; <span class="comment">//释放删除结点的空间</span></span><br><span class="line">    --length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示所有图书</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showdata</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LinkList p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"当前记录为空"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        p = L-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; <span class="string">"书名："</span> &lt;&lt; p-&gt;data.name &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">"ISBN："</span> &lt;&lt; p-&gt;data.isbn &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">"价格："</span> &lt;&lt; p-&gt;data.price &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"*************************"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  1、建立图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  2、输入图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  3、图书取值  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  4、查找图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  5、插入图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  6、图书删除  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  7、所有图书  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*****  0、退出 BMS  *****"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*************************"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    string name;</span><br><span class="line">    Book e;</span><br><span class="line">    LinkList L, p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">showMenu</span>();</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; select;</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(select)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">InitList</span>(L))</span><br><span class="line">                cout &lt;&lt; <span class="string">"成功建立链表"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">CreateList</span>(L, length);</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入信息完毕"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入取值的位置:"</span>;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">GetElem</span>(L, a, e))</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; <span class="string">"查找成功"</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"第"</span> &lt;&lt; a &lt;&lt; <span class="string">"本图书的信息是："</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"ISBN："</span>&lt;&lt; e.isbn &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"书名："</span>&lt;&lt; e.name &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"价格："</span>&lt;&lt; e.price &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"查找失败"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入所要查找书名:"</span>;</span><br><span class="line">            cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">LocateElem</span>(L, name) != <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; <span class="string">"查找成功"</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"该书对应的信息为："</span> &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"ISBN："</span>&lt;&lt; <span class="built_in">LocateElem</span>(L, name)-&gt;data.isbn&lt;&lt;endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"书名："</span>&lt;&lt; <span class="built_in">LocateElem</span>(L, name)-&gt;data.name&lt;&lt;endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">"价格："</span>&lt;&lt; <span class="built_in">LocateElem</span>(L, name)-&gt;data.price&lt;&lt;endl;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"查找失败《"</span> &lt;&lt; name &lt;&lt; <span class="string">"》没有找到"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的位置："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; b;</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的书的名字："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; e.name;</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的书的ISBN："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; e.isbn;</span><br><span class="line">            cout &lt;&lt; <span class="string">"想要插入的书的价格："</span> &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; e.price;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListInsert</span>(L, b, e))</span><br><span class="line">            {   </span><br><span class="line">ofstream outlife;</span><br><span class="line">    outlife.<span class="built_in">open</span>(<span class="string">"book.txt"</span>,ios::out | ios::in |ios::app);</span><br><span class="line">    outlife&lt;&lt;e.isbn&lt;&lt;endl;</span><br><span class="line">    outlife&lt;&lt;e.name&lt;&lt;endl;</span><br><span class="line">    outlife&lt;&lt;e.price&lt;&lt;endl;</span><br><span class="line">    outlife.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"插入成功"</span> &lt;&lt; endl;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"插入失败"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入所要删除的书籍的位置:"</span>;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListDelete</span>(L, c))</span><br><span class="line">                cout &lt;&lt; <span class="string">"删除成功!\n\n"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">"删除失败!\n\n"</span>;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            p = L-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(p)</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; p-&gt;data.isbn &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; p-&gt;data.name &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; p-&gt;data.price &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"cls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"退出成功"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/17/hello-world/"/>
      <url>2021/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
